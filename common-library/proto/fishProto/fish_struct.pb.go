// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fish_struct.proto

package fishProto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//创建捕鱼房间
type C2SCreateFishRoom struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SCreateFishRoom) Reset()         { *m = C2SCreateFishRoom{} }
func (m *C2SCreateFishRoom) String() string { return proto.CompactTextString(m) }
func (*C2SCreateFishRoom) ProtoMessage()    {}
func (*C2SCreateFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{0}
}
func (m *C2SCreateFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SCreateFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SCreateFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SCreateFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SCreateFishRoom.Merge(m, src)
}
func (m *C2SCreateFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SCreateFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SCreateFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SCreateFishRoom proto.InternalMessageInfo

type S2CCreateFishRoom struct {
	RoomId string `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 [0, 3]
	SeatIndex int32 `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	// 玩家基本信息
	PlayerBaseInfo *PlayerBaseInfo `protobuf:"bytes,3,opt,name=playerBaseInfo,proto3" json:"playerBaseInfo,omitempty"`
	// 房间创建时的时间戳
	RoomCrTimestamp int64 `protobuf:"varint,4,opt,name=roomCrTimestamp,proto3" json:"roomCrTimestamp,omitempty"`
	// 当前时间戳
	CurTimestamp         int64    `protobuf:"varint,5,opt,name=curTimestamp,proto3" json:"curTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CCreateFishRoom) Reset()         { *m = S2CCreateFishRoom{} }
func (m *S2CCreateFishRoom) String() string { return proto.CompactTextString(m) }
func (*S2CCreateFishRoom) ProtoMessage()    {}
func (*S2CCreateFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{1}
}
func (m *S2CCreateFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CCreateFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CCreateFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CCreateFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CCreateFishRoom.Merge(m, src)
}
func (m *S2CCreateFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CCreateFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CCreateFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CCreateFishRoom proto.InternalMessageInfo

func (m *S2CCreateFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2CCreateFishRoom) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

func (m *S2CCreateFishRoom) GetPlayerBaseInfo() *PlayerBaseInfo {
	if m != nil {
		return m.PlayerBaseInfo
	}
	return nil
}

func (m *S2CCreateFishRoom) GetRoomCrTimestamp() int64 {
	if m != nil {
		return m.RoomCrTimestamp
	}
	return 0
}

func (m *S2CCreateFishRoom) GetCurTimestamp() int64 {
	if m != nil {
		return m.CurTimestamp
	}
	return 0
}

// 房间内的玩家信息
type PlayerBaseInfo struct {
	Uid uint32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// 昵称
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// 金币
	GoldCoin             int64    `protobuf:"varint,3,opt,name=goldCoin,proto3" json:"goldCoin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlayerBaseInfo) Reset()         { *m = PlayerBaseInfo{} }
func (m *PlayerBaseInfo) String() string { return proto.CompactTextString(m) }
func (*PlayerBaseInfo) ProtoMessage()    {}
func (*PlayerBaseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{2}
}
func (m *PlayerBaseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlayerBaseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlayerBaseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlayerBaseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlayerBaseInfo.Merge(m, src)
}
func (m *PlayerBaseInfo) XXX_Size() int {
	return m.Size()
}
func (m *PlayerBaseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PlayerBaseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PlayerBaseInfo proto.InternalMessageInfo

func (m *PlayerBaseInfo) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *PlayerBaseInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerBaseInfo) GetGoldCoin() int64 {
	if m != nil {
		return m.GoldCoin
	}
	return 0
}

// 进入捕鱼房间
type C2SEnterFishRoom struct {
	RoomId               string   `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SEnterFishRoom) Reset()         { *m = C2SEnterFishRoom{} }
func (m *C2SEnterFishRoom) String() string { return proto.CompactTextString(m) }
func (*C2SEnterFishRoom) ProtoMessage()    {}
func (*C2SEnterFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{3}
}
func (m *C2SEnterFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SEnterFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SEnterFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SEnterFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SEnterFishRoom.Merge(m, src)
}
func (m *C2SEnterFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SEnterFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SEnterFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SEnterFishRoom proto.InternalMessageInfo

func (m *C2SEnterFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

type S2CEnterFishRoom struct {
	RoomId string `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 [0, 3]
	SeatIndex int32 `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	// 玩家基本信息
	PlayerBaseInfo *PlayerBaseInfo `protobuf:"bytes,3,opt,name=playerBaseInfo,proto3" json:"playerBaseInfo,omitempty"`
	// 房间创建时的时间戳
	RoomCrTimestamp int64 `protobuf:"varint,4,opt,name=roomCrTimestamp,proto3" json:"roomCrTimestamp,omitempty"`
	// 当前时间戳
	CurTimestamp         int64    `protobuf:"varint,5,opt,name=curTimestamp,proto3" json:"curTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CEnterFishRoom) Reset()         { *m = S2CEnterFishRoom{} }
func (m *S2CEnterFishRoom) String() string { return proto.CompactTextString(m) }
func (*S2CEnterFishRoom) ProtoMessage()    {}
func (*S2CEnterFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{4}
}
func (m *S2CEnterFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CEnterFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CEnterFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CEnterFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CEnterFishRoom.Merge(m, src)
}
func (m *S2CEnterFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CEnterFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CEnterFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CEnterFishRoom proto.InternalMessageInfo

func (m *S2CEnterFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2CEnterFishRoom) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

func (m *S2CEnterFishRoom) GetPlayerBaseInfo() *PlayerBaseInfo {
	if m != nil {
		return m.PlayerBaseInfo
	}
	return nil
}

func (m *S2CEnterFishRoom) GetRoomCrTimestamp() int64 {
	if m != nil {
		return m.RoomCrTimestamp
	}
	return 0
}

func (m *S2CEnterFishRoom) GetCurTimestamp() int64 {
	if m != nil {
		return m.CurTimestamp
	}
	return 0
}

// 进入捕鱼房间后,服务器下推先前进入房间的玩家信息
type S2COtherPlayerInfoInFishRoom struct {
	RoomId               string            `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	PlayerBaseInfos      []*PlayerBaseInfo `protobuf:"bytes,2,rep,name=playerBaseInfos,proto3" json:"playerBaseInfos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *S2COtherPlayerInfoInFishRoom) Reset()         { *m = S2COtherPlayerInfoInFishRoom{} }
func (m *S2COtherPlayerInfoInFishRoom) String() string { return proto.CompactTextString(m) }
func (*S2COtherPlayerInfoInFishRoom) ProtoMessage()    {}
func (*S2COtherPlayerInfoInFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{5}
}
func (m *S2COtherPlayerInfoInFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2COtherPlayerInfoInFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2COtherPlayerInfoInFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2COtherPlayerInfoInFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2COtherPlayerInfoInFishRoom.Merge(m, src)
}
func (m *S2COtherPlayerInfoInFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2COtherPlayerInfoInFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2COtherPlayerInfoInFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2COtherPlayerInfoInFishRoom proto.InternalMessageInfo

func (m *S2COtherPlayerInfoInFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2COtherPlayerInfoInFishRoom) GetPlayerBaseInfos() []*PlayerBaseInfo {
	if m != nil {
		return m.PlayerBaseInfos
	}
	return nil
}

// 通知用户,有其他人进入房间
type S2COtherPlayerEnterFishRoom struct {
	RoomId string `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 [0, 3]
	SeatIndex int32 `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	// 玩家基本信息
	PlayerBaseInfo       *PlayerBaseInfo `protobuf:"bytes,3,opt,name=playerBaseInfo,proto3" json:"playerBaseInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *S2COtherPlayerEnterFishRoom) Reset()         { *m = S2COtherPlayerEnterFishRoom{} }
func (m *S2COtherPlayerEnterFishRoom) String() string { return proto.CompactTextString(m) }
func (*S2COtherPlayerEnterFishRoom) ProtoMessage()    {}
func (*S2COtherPlayerEnterFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{6}
}
func (m *S2COtherPlayerEnterFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2COtherPlayerEnterFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2COtherPlayerEnterFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2COtherPlayerEnterFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2COtherPlayerEnterFishRoom.Merge(m, src)
}
func (m *S2COtherPlayerEnterFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2COtherPlayerEnterFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2COtherPlayerEnterFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2COtherPlayerEnterFishRoom proto.InternalMessageInfo

func (m *S2COtherPlayerEnterFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2COtherPlayerEnterFishRoom) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

func (m *S2COtherPlayerEnterFishRoom) GetPlayerBaseInfo() *PlayerBaseInfo {
	if m != nil {
		return m.PlayerBaseInfo
	}
	return nil
}

// 离开捕鱼房间
type C2SLeaveFishRoom struct {
	RoomId               string   `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SLeaveFishRoom) Reset()         { *m = C2SLeaveFishRoom{} }
func (m *C2SLeaveFishRoom) String() string { return proto.CompactTextString(m) }
func (*C2SLeaveFishRoom) ProtoMessage()    {}
func (*C2SLeaveFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{7}
}
func (m *C2SLeaveFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SLeaveFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SLeaveFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SLeaveFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SLeaveFishRoom.Merge(m, src)
}
func (m *C2SLeaveFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SLeaveFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SLeaveFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SLeaveFishRoom proto.InternalMessageInfo

func (m *C2SLeaveFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

type S2CLeaveFishRoom struct {
	RoomId string `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 [0, 3]
	SeatIndex            int32    `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CLeaveFishRoom) Reset()         { *m = S2CLeaveFishRoom{} }
func (m *S2CLeaveFishRoom) String() string { return proto.CompactTextString(m) }
func (*S2CLeaveFishRoom) ProtoMessage()    {}
func (*S2CLeaveFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{8}
}
func (m *S2CLeaveFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CLeaveFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CLeaveFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CLeaveFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CLeaveFishRoom.Merge(m, src)
}
func (m *S2CLeaveFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CLeaveFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CLeaveFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CLeaveFishRoom proto.InternalMessageInfo

func (m *S2CLeaveFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2CLeaveFishRoom) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

// 离开捕鱼房间后,广播
type S2CBroadcastLeaveFishRoom struct {
	RoomId string `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 [0, 3]
	SeatIndex            int32    `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CBroadcastLeaveFishRoom) Reset()         { *m = S2CBroadcastLeaveFishRoom{} }
func (m *S2CBroadcastLeaveFishRoom) String() string { return proto.CompactTextString(m) }
func (*S2CBroadcastLeaveFishRoom) ProtoMessage()    {}
func (*S2CBroadcastLeaveFishRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{9}
}
func (m *S2CBroadcastLeaveFishRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CBroadcastLeaveFishRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CBroadcastLeaveFishRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CBroadcastLeaveFishRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CBroadcastLeaveFishRoom.Merge(m, src)
}
func (m *S2CBroadcastLeaveFishRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CBroadcastLeaveFishRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CBroadcastLeaveFishRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CBroadcastLeaveFishRoom proto.InternalMessageInfo

func (m *S2CBroadcastLeaveFishRoom) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2CBroadcastLeaveFishRoom) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

// 房间内的客户端断线通知
type S2CFishClientDisconnect struct {
	RoomId string `protobuf:"bytes,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 [0, 3]
	SeatIndex            int32    `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CFishClientDisconnect) Reset()         { *m = S2CFishClientDisconnect{} }
func (m *S2CFishClientDisconnect) String() string { return proto.CompactTextString(m) }
func (*S2CFishClientDisconnect) ProtoMessage()    {}
func (*S2CFishClientDisconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{10}
}
func (m *S2CFishClientDisconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CFishClientDisconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CFishClientDisconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CFishClientDisconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CFishClientDisconnect.Merge(m, src)
}
func (m *S2CFishClientDisconnect) XXX_Size() int {
	return m.Size()
}
func (m *S2CFishClientDisconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CFishClientDisconnect.DiscardUnknown(m)
}

var xxx_messageInfo_S2CFishClientDisconnect proto.InternalMessageInfo

func (m *S2CFishClientDisconnect) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *S2CFishClientDisconnect) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

//生成鱼
type S2CCreateFish struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CCreateFish) Reset()         { *m = S2CCreateFish{} }
func (m *S2CCreateFish) String() string { return proto.CompactTextString(m) }
func (*S2CCreateFish) ProtoMessage()    {}
func (*S2CCreateFish) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{11}
}
func (m *S2CCreateFish) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CCreateFish) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CCreateFish.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CCreateFish) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CCreateFish.Merge(m, src)
}
func (m *S2CCreateFish) XXX_Size() int {
	return m.Size()
}
func (m *S2CCreateFish) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CCreateFish.DiscardUnknown(m)
}

var xxx_messageInfo_S2CCreateFish proto.InternalMessageInfo

// 客户端请求一枚子弹
type C2SPlayerShoot struct {
	// 下注数, 子弹价钱
	BetMultiple int64 `protobuf:"varint,1,opt,name=bet_multiple,json=betMultiple,proto3" json:"bet_multiple,omitempty"`
	// 子弹 X 方向
	Forwardx int32 `protobuf:"varint,2,opt,name=forwardx,proto3" json:"forwardx,omitempty"`
	// 子弹 Y 方向
	Forwardy int32 `protobuf:"varint,3,opt,name=forwardy,proto3" json:"forwardy,omitempty"`
	// 子弹 Z 方向
	Forwardz int32 `protobuf:"varint,4,opt,name=forwardz,proto3" json:"forwardz,omitempty"`
	// 要打哪条鱼
	FishId               int64    `protobuf:"varint,5,opt,name=fishId,proto3" json:"fishId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SPlayerShoot) Reset()         { *m = C2SPlayerShoot{} }
func (m *C2SPlayerShoot) String() string { return proto.CompactTextString(m) }
func (*C2SPlayerShoot) ProtoMessage()    {}
func (*C2SPlayerShoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{12}
}
func (m *C2SPlayerShoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SPlayerShoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SPlayerShoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SPlayerShoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SPlayerShoot.Merge(m, src)
}
func (m *C2SPlayerShoot) XXX_Size() int {
	return m.Size()
}
func (m *C2SPlayerShoot) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SPlayerShoot.DiscardUnknown(m)
}

var xxx_messageInfo_C2SPlayerShoot proto.InternalMessageInfo

func (m *C2SPlayerShoot) GetBetMultiple() int64 {
	if m != nil {
		return m.BetMultiple
	}
	return 0
}

func (m *C2SPlayerShoot) GetForwardx() int32 {
	if m != nil {
		return m.Forwardx
	}
	return 0
}

func (m *C2SPlayerShoot) GetForwardy() int32 {
	if m != nil {
		return m.Forwardy
	}
	return 0
}

func (m *C2SPlayerShoot) GetForwardz() int32 {
	if m != nil {
		return m.Forwardz
	}
	return 0
}

func (m *C2SPlayerShoot) GetFishId() int64 {
	if m != nil {
		return m.FishId
	}
	return 0
}

type S2CPlayerShoot struct {
	C2SMsg *C2SPlayerShoot `protobuf:"bytes,1,opt,name=c2sMsg,proto3" json:"c2sMsg,omitempty"`
	// 子弹 ID, 用时间戳生成
	BulletId string `protobuf:"bytes,2,opt,name=bulletId,proto3" json:"bulletId,omitempty"`
	// 发射子弹的玩家
	Uid                  uint32   `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CPlayerShoot) Reset()         { *m = S2CPlayerShoot{} }
func (m *S2CPlayerShoot) String() string { return proto.CompactTextString(m) }
func (*S2CPlayerShoot) ProtoMessage()    {}
func (*S2CPlayerShoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{13}
}
func (m *S2CPlayerShoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CPlayerShoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CPlayerShoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CPlayerShoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CPlayerShoot.Merge(m, src)
}
func (m *S2CPlayerShoot) XXX_Size() int {
	return m.Size()
}
func (m *S2CPlayerShoot) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CPlayerShoot.DiscardUnknown(m)
}

var xxx_messageInfo_S2CPlayerShoot proto.InternalMessageInfo

func (m *S2CPlayerShoot) GetC2SMsg() *C2SPlayerShoot {
	if m != nil {
		return m.C2SMsg
	}
	return nil
}

func (m *S2CPlayerShoot) GetBulletId() string {
	if m != nil {
		return m.BulletId
	}
	return ""
}

func (m *S2CPlayerShoot) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 客户端击中
type C2SHitShoot struct {
	// 子弹 ID, 服务器用来取 s2cPlayerShoot.bet_multiple
	BulletId string `protobuf:"bytes,1,opt,name=bulletId,proto3" json:"bulletId,omitempty"`
	// XXX 击中鱼 id 列表, 需要验证鱼 id 的合法性,以及生命周期
	Ids                  []int32  `protobuf:"varint,2,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SHitShoot) Reset()         { *m = C2SHitShoot{} }
func (m *C2SHitShoot) String() string { return proto.CompactTextString(m) }
func (*C2SHitShoot) ProtoMessage()    {}
func (*C2SHitShoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{14}
}
func (m *C2SHitShoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SHitShoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SHitShoot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SHitShoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SHitShoot.Merge(m, src)
}
func (m *C2SHitShoot) XXX_Size() int {
	return m.Size()
}
func (m *C2SHitShoot) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SHitShoot.DiscardUnknown(m)
}

var xxx_messageInfo_C2SHitShoot proto.InternalMessageInfo

func (m *C2SHitShoot) GetBulletId() string {
	if m != nil {
		return m.BulletId
	}
	return ""
}

func (m *C2SHitShoot) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

// 服务器返回捕获鱼通知
type S2CShootAward struct {
	// 子弹 ID
	BulletId string `protobuf:"bytes,1,opt,name=bulletId,proto3" json:"bulletId,omitempty"`
	// 击中鱼 id 列表
	Ids []int32 `protobuf:"varint,2,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	// 对应鱼 id 获取的金币列表
	Coin []int64 `protobuf:"varint,3,rep,packed,name=coin,proto3" json:"coin,omitempty"`
	// 总金币
	TotalCoin int64 `protobuf:"varint,4,opt,name=totalCoin,proto3" json:"totalCoin,omitempty"`
	// 发射子弹的玩家
	Uid                  uint32   `protobuf:"varint,5,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CShootAward) Reset()         { *m = S2CShootAward{} }
func (m *S2CShootAward) String() string { return proto.CompactTextString(m) }
func (*S2CShootAward) ProtoMessage()    {}
func (*S2CShootAward) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d40e60678b6587f, []int{15}
}
func (m *S2CShootAward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CShootAward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CShootAward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CShootAward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CShootAward.Merge(m, src)
}
func (m *S2CShootAward) XXX_Size() int {
	return m.Size()
}
func (m *S2CShootAward) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CShootAward.DiscardUnknown(m)
}

var xxx_messageInfo_S2CShootAward proto.InternalMessageInfo

func (m *S2CShootAward) GetBulletId() string {
	if m != nil {
		return m.BulletId
	}
	return ""
}

func (m *S2CShootAward) GetIds() []int32 {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *S2CShootAward) GetCoin() []int64 {
	if m != nil {
		return m.Coin
	}
	return nil
}

func (m *S2CShootAward) GetTotalCoin() int64 {
	if m != nil {
		return m.TotalCoin
	}
	return 0
}

func (m *S2CShootAward) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func init() {
	proto.RegisterType((*C2SCreateFishRoom)(nil), "fishProto.c2sCreateFishRoom")
	proto.RegisterType((*S2CCreateFishRoom)(nil), "fishProto.s2cCreateFishRoom")
	proto.RegisterType((*PlayerBaseInfo)(nil), "fishProto.playerBaseInfo")
	proto.RegisterType((*C2SEnterFishRoom)(nil), "fishProto.c2sEnterFishRoom")
	proto.RegisterType((*S2CEnterFishRoom)(nil), "fishProto.s2cEnterFishRoom")
	proto.RegisterType((*S2COtherPlayerInfoInFishRoom)(nil), "fishProto.s2cOtherPlayerInfoInFishRoom")
	proto.RegisterType((*S2COtherPlayerEnterFishRoom)(nil), "fishProto.s2cOtherPlayerEnterFishRoom")
	proto.RegisterType((*C2SLeaveFishRoom)(nil), "fishProto.c2sLeaveFishRoom")
	proto.RegisterType((*S2CLeaveFishRoom)(nil), "fishProto.s2cLeaveFishRoom")
	proto.RegisterType((*S2CBroadcastLeaveFishRoom)(nil), "fishProto.s2cBroadcastLeaveFishRoom")
	proto.RegisterType((*S2CFishClientDisconnect)(nil), "fishProto.s2cFishClientDisconnect")
	proto.RegisterType((*S2CCreateFish)(nil), "fishProto.s2cCreateFish")
	proto.RegisterType((*C2SPlayerShoot)(nil), "fishProto.c2sPlayerShoot")
	proto.RegisterType((*S2CPlayerShoot)(nil), "fishProto.s2cPlayerShoot")
	proto.RegisterType((*C2SHitShoot)(nil), "fishProto.c2sHitShoot")
	proto.RegisterType((*S2CShootAward)(nil), "fishProto.s2cShootAward")
}

func init() { proto.RegisterFile("fish_struct.proto", fileDescriptor_9d40e60678b6587f) }

var fileDescriptor_9d40e60678b6587f = []byte{
	// 582 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0x66, 0xeb, 0xa6, 0x22, 0x93, 0x36, 0x3f, 0x0b, 0x2a, 0x29, 0x54, 0x51, 0xd8, 0x93, 0xc5,
	0x21, 0x12, 0xcb, 0x03, 0xa0, 0x26, 0x80, 0x6a, 0x89, 0xaa, 0x65, 0xe1, 0x5e, 0x39, 0xeb, 0x4d,
	0x63, 0xc9, 0xf6, 0x06, 0xef, 0x06, 0x48, 0x79, 0x02, 0x5e, 0x00, 0x71, 0xe3, 0x75, 0x38, 0x72,
	0x85, 0x13, 0x0a, 0x2f, 0x82, 0x76, 0xed, 0x38, 0x71, 0x0e, 0x4d, 0x41, 0x1c, 0xe0, 0xe6, 0xf9,
	0xe6, 0xf7, 0x9b, 0x99, 0x1d, 0x43, 0x6b, 0x14, 0xaa, 0xf1, 0xb9, 0xd2, 0xe9, 0x94, 0xeb, 0xde,
	0x24, 0x95, 0x5a, 0xe2, 0xaa, 0x81, 0xce, 0xcc, 0x27, 0xb9, 0x05, 0x2d, 0x4e, 0xd5, 0x20, 0x15,
	0xbe, 0x16, 0xcf, 0x42, 0x35, 0x66, 0x52, 0xc6, 0xe4, 0x3b, 0x82, 0x96, 0xa2, 0xbc, 0x8c, 0xe2,
	0x7d, 0xd8, 0x49, 0xa5, 0x8c, 0xbd, 0xa0, 0x8d, 0xba, 0xc8, 0xad, 0xb2, 0x5c, 0xc2, 0x87, 0x50,
	0x55, 0xc2, 0xd7, 0x5e, 0x12, 0x88, 0x77, 0xed, 0xad, 0x2e, 0x72, 0x2b, 0x6c, 0x09, 0xe0, 0x23,
	0xa8, 0x4f, 0x22, 0x7f, 0x26, 0xd2, 0xbe, 0xaf, 0x84, 0x97, 0x8c, 0x64, 0xdb, 0xe9, 0x22, 0xb7,
	0x46, 0x0f, 0x7a, 0x45, 0x11, 0xbd, 0xb2, 0x01, 0x5b, 0x73, 0xc0, 0x2e, 0x34, 0x4c, 0xaa, 0x41,
	0xfa, 0x2a, 0x8c, 0x85, 0xd2, 0x7e, 0x3c, 0x69, 0x6f, 0x77, 0x91, 0xeb, 0xb0, 0x75, 0x18, 0x13,
	0xd8, 0xe5, 0xd3, 0x15, 0xb3, 0x8a, 0x35, 0x2b, 0x61, 0x84, 0xad, 0x17, 0x84, 0x9b, 0xe0, 0x4c,
	0xc3, 0x8c, 0xd5, 0x1e, 0x33, 0x9f, 0x18, 0xc3, 0x76, 0xe2, 0xc7, 0xc2, 0xb2, 0xa9, 0x32, 0xfb,
	0x8d, 0xef, 0xc2, 0xcd, 0x0b, 0x19, 0x05, 0x03, 0x19, 0x26, 0x96, 0x82, 0xc3, 0x0a, 0x99, 0x3c,
	0x80, 0x26, 0xa7, 0xea, 0x69, 0xa2, 0x45, 0xba, 0xa9, 0x5d, 0xe4, 0x1b, 0x82, 0xa6, 0xa2, 0xfc,
	0x5a, 0xc6, 0xff, 0x5b, 0x6f, 0xdf, 0xc3, 0xa1, 0xa2, 0xfc, 0x54, 0x8f, 0x45, 0x7a, 0x66, 0xf3,
	0x98, 0x1c, 0x5e, 0xb2, 0x91, 0xe6, 0x00, 0x1a, 0xe5, 0xba, 0x54, 0x7b, 0xab, 0xeb, 0x5c, 0xcd,
	0x64, 0xdd, 0x83, 0x7c, 0x44, 0x70, 0xaf, 0x9c, 0xfd, 0xdf, 0xe8, 0x71, 0xbe, 0x1d, 0xcf, 0x85,
	0xff, 0x66, 0xe3, 0x63, 0x22, 0xc7, 0x76, 0x39, 0xae, 0x65, 0x7b, 0x75, 0xe1, 0xe4, 0x05, 0x1c,
	0x28, 0xca, 0xfb, 0xa9, 0xf4, 0x03, 0xee, 0x2b, 0xfd, 0x37, 0x42, 0x9e, 0xc2, 0x1d, 0x45, 0xb9,
	0x09, 0x32, 0x88, 0x42, 0x91, 0xe8, 0x27, 0xa1, 0xe2, 0x32, 0x49, 0x04, 0xd7, 0x7f, 0x18, 0xb0,
	0x01, 0x7b, 0xa5, 0x3b, 0x43, 0x3e, 0x23, 0xa8, 0x73, 0xaa, 0xb2, 0xf1, 0xbd, 0x1c, 0x4b, 0xa9,
	0xf1, 0x7d, 0xd8, 0x1d, 0x0a, 0x7d, 0x1e, 0x4f, 0x23, 0x1d, 0x4e, 0x22, 0x61, 0xe3, 0x3b, 0xac,
	0x36, 0x14, 0xfa, 0x24, 0x87, 0xcc, 0xd3, 0x1c, 0xc9, 0xf4, 0xad, 0x9f, 0x06, 0x8b, 0x1c, 0x85,
	0xbc, 0xa2, 0x9b, 0xd9, 0xc9, 0x2d, 0x75, 0xb3, 0x15, 0xdd, 0xa5, 0xdd, 0xfa, 0xa5, 0xee, 0xd2,
	0x10, 0x32, 0x03, 0xf6, 0x82, 0x7c, 0xd1, 0x73, 0x89, 0xbc, 0x86, 0xba, 0xa2, 0x7c, 0xb5, 0xc0,
	0x87, 0xb0, 0xc3, 0xa9, 0x3a, 0x51, 0x17, 0xb6, 0xb4, 0xf2, 0x66, 0x94, 0xb9, 0xb0, 0xdc, 0xd0,
	0x24, 0x1e, 0x4e, 0xa3, 0x48, 0x68, 0x2f, 0xc8, 0x6f, 0x4c, 0x21, 0x2f, 0xae, 0x91, 0x53, 0x5c,
	0x23, 0xf2, 0x18, 0x6a, 0x9c, 0xaa, 0xe3, 0x50, 0x67, 0xf9, 0x56, 0x9d, 0xd1, 0x9a, 0xf3, 0x6d,
	0x70, 0xc2, 0x20, 0x7b, 0x3c, 0x95, 0xfe, 0x56, 0x13, 0x31, 0x23, 0x92, 0x0f, 0xc8, 0xf6, 0xd9,
	0xba, 0x1f, 0x19, 0x7a, 0xbf, 0x1f, 0x03, 0xef, 0xc3, 0x36, 0xcf, 0x4e, 0x9f, 0xe3, 0x3a, 0x16,
	0xb6, 0xb2, 0x19, 0xb0, 0x96, 0xda, 0x8f, 0xec, 0x5d, 0xcc, 0x4e, 0xc7, 0x12, 0x58, 0x90, 0xa9,
	0x14, 0x64, 0xfa, 0xcd, 0x2f, 0xf3, 0x0e, 0xfa, 0x3a, 0xef, 0xa0, 0x1f, 0xf3, 0x0e, 0xfa, 0xf4,
	0xb3, 0x73, 0x63, 0xb8, 0x63, 0x7f, 0x4a, 0x8f, 0x7e, 0x05, 0x00, 0x00, 0xff, 0xff, 0xb9, 0xbb,
	0x4d, 0x63, 0xa9, 0x06, 0x00, 0x00,
}

func (m *C2SCreateFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SCreateFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SCreateFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *S2CCreateFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CCreateFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CCreateFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurTimestamp != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.CurTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.RoomCrTimestamp != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.RoomCrTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerBaseInfo != nil {
		{
			size, err := m.PlayerBaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFishStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SeatIndex != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlayerBaseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerBaseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlayerBaseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GoldCoin != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.GoldCoin))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Uid != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SEnterFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SEnterFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SEnterFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CEnterFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CEnterFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CEnterFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurTimestamp != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.CurTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.RoomCrTimestamp != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.RoomCrTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerBaseInfo != nil {
		{
			size, err := m.PlayerBaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFishStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SeatIndex != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2COtherPlayerInfoInFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COtherPlayerInfoInFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2COtherPlayerInfoInFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PlayerBaseInfos) > 0 {
		for iNdEx := len(m.PlayerBaseInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayerBaseInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFishStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2COtherPlayerEnterFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COtherPlayerEnterFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2COtherPlayerEnterFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerBaseInfo != nil {
		{
			size, err := m.PlayerBaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFishStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SeatIndex != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2SLeaveFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SLeaveFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SLeaveFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CLeaveFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CLeaveFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CLeaveFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatIndex != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CBroadcastLeaveFishRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CBroadcastLeaveFishRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CBroadcastLeaveFishRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatIndex != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CFishClientDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CFishClientDisconnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CFishClientDisconnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatIndex != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RoomId) > 0 {
		i -= len(m.RoomId)
		copy(dAtA[i:], m.RoomId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.RoomId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CCreateFish) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CCreateFish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CCreateFish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *C2SPlayerShoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SPlayerShoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SPlayerShoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FishId != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.FishId))
		i--
		dAtA[i] = 0x28
	}
	if m.Forwardz != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.Forwardz))
		i--
		dAtA[i] = 0x20
	}
	if m.Forwardy != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.Forwardy))
		i--
		dAtA[i] = 0x18
	}
	if m.Forwardx != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.Forwardx))
		i--
		dAtA[i] = 0x10
	}
	if m.BetMultiple != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.BetMultiple))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CPlayerShoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CPlayerShoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CPlayerShoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BulletId) > 0 {
		i -= len(m.BulletId)
		copy(dAtA[i:], m.BulletId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.BulletId)))
		i--
		dAtA[i] = 0x12
	}
	if m.C2SMsg != nil {
		{
			size, err := m.C2SMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFishStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2SHitShoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SHitShoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SHitShoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Ids) > 0 {
		dAtA6 := make([]byte, len(m.Ids)*10)
		var j5 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintFishStruct(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BulletId) > 0 {
		i -= len(m.BulletId)
		copy(dAtA[i:], m.BulletId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.BulletId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CShootAward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CShootAward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CShootAward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalCoin != 0 {
		i = encodeVarintFishStruct(dAtA, i, uint64(m.TotalCoin))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Coin) > 0 {
		dAtA8 := make([]byte, len(m.Coin)*10)
		var j7 int
		for _, num1 := range m.Coin {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintFishStruct(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Ids) > 0 {
		dAtA10 := make([]byte, len(m.Ids)*10)
		var j9 int
		for _, num1 := range m.Ids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintFishStruct(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BulletId) > 0 {
		i -= len(m.BulletId)
		copy(dAtA[i:], m.BulletId)
		i = encodeVarintFishStruct(dAtA, i, uint64(len(m.BulletId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFishStruct(dAtA []byte, offset int, v uint64) int {
	offset -= sovFishStruct(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *C2SCreateFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CCreateFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovFishStruct(uint64(m.SeatIndex))
	}
	if m.PlayerBaseInfo != nil {
		l = m.PlayerBaseInfo.Size()
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.RoomCrTimestamp != 0 {
		n += 1 + sovFishStruct(uint64(m.RoomCrTimestamp))
	}
	if m.CurTimestamp != 0 {
		n += 1 + sovFishStruct(uint64(m.CurTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlayerBaseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovFishStruct(uint64(m.Uid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.GoldCoin != 0 {
		n += 1 + sovFishStruct(uint64(m.GoldCoin))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SEnterFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CEnterFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovFishStruct(uint64(m.SeatIndex))
	}
	if m.PlayerBaseInfo != nil {
		l = m.PlayerBaseInfo.Size()
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.RoomCrTimestamp != 0 {
		n += 1 + sovFishStruct(uint64(m.RoomCrTimestamp))
	}
	if m.CurTimestamp != 0 {
		n += 1 + sovFishStruct(uint64(m.CurTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2COtherPlayerInfoInFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if len(m.PlayerBaseInfos) > 0 {
		for _, e := range m.PlayerBaseInfos {
			l = e.Size()
			n += 1 + l + sovFishStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2COtherPlayerEnterFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovFishStruct(uint64(m.SeatIndex))
	}
	if m.PlayerBaseInfo != nil {
		l = m.PlayerBaseInfo.Size()
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SLeaveFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CLeaveFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovFishStruct(uint64(m.SeatIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CBroadcastLeaveFishRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovFishStruct(uint64(m.SeatIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CFishClientDisconnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovFishStruct(uint64(m.SeatIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CCreateFish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SPlayerShoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BetMultiple != 0 {
		n += 1 + sovFishStruct(uint64(m.BetMultiple))
	}
	if m.Forwardx != 0 {
		n += 1 + sovFishStruct(uint64(m.Forwardx))
	}
	if m.Forwardy != 0 {
		n += 1 + sovFishStruct(uint64(m.Forwardy))
	}
	if m.Forwardz != 0 {
		n += 1 + sovFishStruct(uint64(m.Forwardz))
	}
	if m.FishId != 0 {
		n += 1 + sovFishStruct(uint64(m.FishId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CPlayerShoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.C2SMsg != nil {
		l = m.C2SMsg.Size()
		n += 1 + l + sovFishStruct(uint64(l))
	}
	l = len(m.BulletId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovFishStruct(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SHitShoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BulletId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovFishStruct(uint64(e))
		}
		n += 1 + sovFishStruct(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CShootAward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BulletId)
	if l > 0 {
		n += 1 + l + sovFishStruct(uint64(l))
	}
	if len(m.Ids) > 0 {
		l = 0
		for _, e := range m.Ids {
			l += sovFishStruct(uint64(e))
		}
		n += 1 + sovFishStruct(uint64(l)) + l
	}
	if len(m.Coin) > 0 {
		l = 0
		for _, e := range m.Coin {
			l += sovFishStruct(uint64(e))
		}
		n += 1 + sovFishStruct(uint64(l)) + l
	}
	if m.TotalCoin != 0 {
		n += 1 + sovFishStruct(uint64(m.TotalCoin))
	}
	if m.Uid != 0 {
		n += 1 + sovFishStruct(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovFishStruct(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFishStruct(x uint64) (n int) {
	return sovFishStruct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *C2SCreateFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sCreateFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sCreateFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CCreateFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cCreateFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cCreateFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerBaseInfo == nil {
				m.PlayerBaseInfo = &PlayerBaseInfo{}
			}
			if err := m.PlayerBaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomCrTimestamp", wireType)
			}
			m.RoomCrTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomCrTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurTimestamp", wireType)
			}
			m.CurTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerBaseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playerBaseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playerBaseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldCoin", wireType)
			}
			m.GoldCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoldCoin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SEnterFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sEnterFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sEnterFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CEnterFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cEnterFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cEnterFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerBaseInfo == nil {
				m.PlayerBaseInfo = &PlayerBaseInfo{}
			}
			if err := m.PlayerBaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomCrTimestamp", wireType)
			}
			m.RoomCrTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomCrTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurTimestamp", wireType)
			}
			m.CurTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COtherPlayerInfoInFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cOtherPlayerInfoInFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cOtherPlayerInfoInFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBaseInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerBaseInfos = append(m.PlayerBaseInfos, &PlayerBaseInfo{})
			if err := m.PlayerBaseInfos[len(m.PlayerBaseInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COtherPlayerEnterFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cOtherPlayerEnterFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cOtherPlayerEnterFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerBaseInfo == nil {
				m.PlayerBaseInfo = &PlayerBaseInfo{}
			}
			if err := m.PlayerBaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SLeaveFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sLeaveFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sLeaveFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CLeaveFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cLeaveFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cLeaveFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CBroadcastLeaveFishRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cBroadcastLeaveFishRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cBroadcastLeaveFishRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CFishClientDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cFishClientDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cFishClientDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CCreateFish) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cCreateFish: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cCreateFish: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SPlayerShoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sPlayerShoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sPlayerShoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetMultiple", wireType)
			}
			m.BetMultiple = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetMultiple |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forwardx", wireType)
			}
			m.Forwardx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forwardx |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forwardy", wireType)
			}
			m.Forwardy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forwardy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forwardz", wireType)
			}
			m.Forwardz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forwardz |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FishId", wireType)
			}
			m.FishId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FishId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CPlayerShoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cPlayerShoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cPlayerShoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2SMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.C2SMsg == nil {
				m.C2SMsg = &C2SPlayerShoot{}
			}
			if err := m.C2SMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SHitShoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sHitShoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sHitShoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFishStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFishStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFishStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CShootAward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cShootAward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cShootAward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BulletId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BulletId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ids = append(m.Ids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFishStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFishStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ids) == 0 {
					m.Ids = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFishStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ids = append(m.Ids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Coin = append(m.Coin, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFishStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFishStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Coin) == 0 {
					m.Coin = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFishStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Coin = append(m.Coin, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCoin", wireType)
			}
			m.TotalCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCoin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFishStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFishStruct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFishStruct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFishStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFishStruct
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFishStruct
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFishStruct
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFishStruct        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFishStruct          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFishStruct = fmt.Errorf("proto: unexpected end of group")
)

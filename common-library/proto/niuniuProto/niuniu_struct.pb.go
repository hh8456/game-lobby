// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: niuniu_struct.proto

package niuniuProto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	commonProto "servers/common-library/proto/commonProto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// 牛牛房间状态
type NiuniuRoomStatus int32

const (
	NiuniuRoomStatus_niuniuRoomStatusNone NiuniuRoomStatus = 0
	// 准备中
	NiuniuRoomStatus_niuniuRoomStatusReady NiuniuRoomStatus = 1
	// 倒计时
	NiuniuRoomStatus_niuniuRoomStatusCountDown NiuniuRoomStatus = 6
	// 抢庄
	NiuniuRoomStatus_niuniuRoomStatusRobZhuang NiuniuRoomStatus = 2
	// 下注
	NiuniuRoomStatus_niuniuRoomStatusBet NiuniuRoomStatus = 3
	// 游戏中, 亮牌
	NiuniuRoomStatus_niuniuRoomStatusPlay NiuniuRoomStatus = 4
	// 结算
	NiuniuRoomStatus_niuniuRoomStatusSettle NiuniuRoomStatus = 5
	//局数已打完
	NiuniuRoomStatus_niuniuRoomStatusGameOver NiuniuRoomStatus = 7
)

var NiuniuRoomStatus_name = map[int32]string{
	0: "niuniuRoomStatusNone",
	1: "niuniuRoomStatusReady",
	6: "niuniuRoomStatusCountDown",
	2: "niuniuRoomStatusRobZhuang",
	3: "niuniuRoomStatusBet",
	4: "niuniuRoomStatusPlay",
	5: "niuniuRoomStatusSettle",
	7: "niuniuRoomStatusGameOver",
}

var NiuniuRoomStatus_value = map[string]int32{
	"niuniuRoomStatusNone":      0,
	"niuniuRoomStatusReady":     1,
	"niuniuRoomStatusCountDown": 6,
	"niuniuRoomStatusRobZhuang": 2,
	"niuniuRoomStatusBet":       3,
	"niuniuRoomStatusPlay":      4,
	"niuniuRoomStatusSettle":    5,
	"niuniuRoomStatusGameOver":  7,
}

func (x NiuniuRoomStatus) String() string {
	return proto.EnumName(NiuniuRoomStatus_name, int32(x))
}

func (NiuniuRoomStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{0}
}

// 牛牛牌型
type NiuniuCardType int32

const (
	// 无牛
	NiuniuCardType_niuniuCardType_0 NiuniuCardType = 0
	// 牛1
	NiuniuCardType_niuniuCardType_1 NiuniuCardType = 1
	// 牛2
	NiuniuCardType_niuniuCardType_2 NiuniuCardType = 2
	// 牛3
	NiuniuCardType_niuniuCardType_3 NiuniuCardType = 3
	// 牛4
	NiuniuCardType_niuniuCardType_4 NiuniuCardType = 4
	// 牛5
	NiuniuCardType_niuniuCardType_5 NiuniuCardType = 5
	// 牛6
	NiuniuCardType_niuniuCardType_6 NiuniuCardType = 6
	// 牛7
	NiuniuCardType_niuniuCardType_7 NiuniuCardType = 7
	// 牛8
	NiuniuCardType_niuniuCardType_8 NiuniuCardType = 8
	// 牛9
	NiuniuCardType_niuniuCardType_9 NiuniuCardType = 9
	// 牛牛, 有牛，点数为10或10的倍数
	NiuniuCardType_niuniuCardType_niu NiuniuCardType = 10
	// 顺子牛, 该牌型不需要有牛，只要5张牌组成顺子即可；10JQKA也是顺子
	NiuniuCardType_niuniuCardType_seq NiuniuCardType = 11
	// 五花牛, 有牛，且5张牌均是 10/J/Q/K 中的一种
	NiuniuCardType_niuniuCardType_fiveFlower NiuniuCardType = 12
	// 同花牛, 该牌型不需要有牛，只要5张牌为同一花色即可
	NiuniuCardType_niuniuCardType_sameFlower NiuniuCardType = 13
	// 葫芦牛, 该牌型不需要有牛，只要三张+对子的组合即可
	NiuniuCardType_niuniuCardType_hulu NiuniuCardType = 14
	// 炸弹牛, 5张牌里，有4张牌点数相同即可
	NiuniuCardType_niuniuCardType_boom NiuniuCardType = 15
	// 五小牛, 5张牌的点数加起来不超过10（不含10）
	NiuniuCardType_niuniuCardType_five NiuniuCardType = 16
	// 同花顺, 5张花色相同的顺子；10JQKA也是顺子
	NiuniuCardType_niuniuCardType_straightFlush NiuniuCardType = 17
)

var NiuniuCardType_name = map[int32]string{
	0:  "niuniuCardType_0",
	1:  "niuniuCardType_1",
	2:  "niuniuCardType_2",
	3:  "niuniuCardType_3",
	4:  "niuniuCardType_4",
	5:  "niuniuCardType_5",
	6:  "niuniuCardType_6",
	7:  "niuniuCardType_7",
	8:  "niuniuCardType_8",
	9:  "niuniuCardType_9",
	10: "niuniuCardType_niu",
	11: "niuniuCardType_seq",
	12: "niuniuCardType_fiveFlower",
	13: "niuniuCardType_sameFlower",
	14: "niuniuCardType_hulu",
	15: "niuniuCardType_boom",
	16: "niuniuCardType_five",
	17: "niuniuCardType_straightFlush",
}

var NiuniuCardType_value = map[string]int32{
	"niuniuCardType_0":             0,
	"niuniuCardType_1":             1,
	"niuniuCardType_2":             2,
	"niuniuCardType_3":             3,
	"niuniuCardType_4":             4,
	"niuniuCardType_5":             5,
	"niuniuCardType_6":             6,
	"niuniuCardType_7":             7,
	"niuniuCardType_8":             8,
	"niuniuCardType_9":             9,
	"niuniuCardType_niu":           10,
	"niuniuCardType_seq":           11,
	"niuniuCardType_fiveFlower":    12,
	"niuniuCardType_sameFlower":    13,
	"niuniuCardType_hulu":          14,
	"niuniuCardType_boom":          15,
	"niuniuCardType_five":          16,
	"niuniuCardType_straightFlush": 17,
}

func (x NiuniuCardType) String() string {
	return proto.EnumName(NiuniuCardType_name, int32(x))
}

func (NiuniuCardType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{1}
}

// 房间配置信息
type RoomConfig struct {
	// 房间 id
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 底分
	BaseScore uint32 `protobuf:"varint,2,opt,name=baseScore,proto3" json:"baseScore,omitempty"`
	// 庄家抢庄倍数, map 键是抢庄倍数, map 值无意义; 键意义: 0 - 不抢庄, 1 - 1倍, 2 - 2倍
	MapRobZhuangRate map[uint32]uint32 `protobuf:"bytes,3,rep,name=mapRobZhuangRate,proto3" json:"mapRobZhuangRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map 键是下注倍数, map 值无意义
	MapBetRate map[uint32]uint32 `protobuf:"bytes,4,rep,name=mapBetRate,proto3" json:"mapBetRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map 键是牌型, map 值是牌型倍数
	MapCardTypeRate map[uint32]uint32 `protobuf:"bytes,5,rep,name=mapCardTypeRate,proto3" json:"mapCardTypeRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 是否有蕃
	CardTypeHasKind bool `protobuf:"varint,6,opt,name=cardTypeHasKind,proto3" json:"cardTypeHasKind,omitempty"`
	// 各个阶段的等待时长, 这个字段是服务器使用,客户端忽略
	// 键是房间状态(niuniuRoomStatus) , 值是秒
	MapWaitTime map[uint32]int64 `protobuf:"bytes,7,rep,name=mapWaitTime,proto3" json:"mapWaitTime,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// true 明牌抢庄, false 暗牌抢庄
	KnownCard bool `protobuf:"varint,8,opt,name=knownCard,proto3" json:"knownCard,omitempty"`
	//游戏总局数
	TotalNumberOfGame uint32 `protobuf:"varint,9,opt,name=totalNumberOfGame,proto3" json:"totalNumberOfGame,omitempty"`
	//暗抢庄家 true:暗抢庄家  false:明抢庄家
	KnownRobZhuang bool `protobuf:"varint,10,opt,name=knownRobZhuang,proto3" json:"knownRobZhuang,omitempty"`
	//坎斗
	Kan bool `protobuf:"varint,11,opt,name=kan,proto3" json:"kan,omitempty"`
	//顺斗
	Shun bool `protobuf:"varint,12,opt,name=shun,proto3" json:"shun,omitempty"`
	//加速模式
	Faster               bool     `protobuf:"varint,13,opt,name=faster,proto3" json:"faster,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoomConfig) Reset()         { *m = RoomConfig{} }
func (m *RoomConfig) String() string { return proto.CompactTextString(m) }
func (*RoomConfig) ProtoMessage()    {}
func (*RoomConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{0}
}
func (m *RoomConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomConfig.Merge(m, src)
}
func (m *RoomConfig) XXX_Size() int {
	return m.Size()
}
func (m *RoomConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RoomConfig proto.InternalMessageInfo

func (m *RoomConfig) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomConfig) GetBaseScore() uint32 {
	if m != nil {
		return m.BaseScore
	}
	return 0
}

func (m *RoomConfig) GetMapRobZhuangRate() map[uint32]uint32 {
	if m != nil {
		return m.MapRobZhuangRate
	}
	return nil
}

func (m *RoomConfig) GetMapBetRate() map[uint32]uint32 {
	if m != nil {
		return m.MapBetRate
	}
	return nil
}

func (m *RoomConfig) GetMapCardTypeRate() map[uint32]uint32 {
	if m != nil {
		return m.MapCardTypeRate
	}
	return nil
}

func (m *RoomConfig) GetCardTypeHasKind() bool {
	if m != nil {
		return m.CardTypeHasKind
	}
	return false
}

func (m *RoomConfig) GetMapWaitTime() map[uint32]int64 {
	if m != nil {
		return m.MapWaitTime
	}
	return nil
}

func (m *RoomConfig) GetKnownCard() bool {
	if m != nil {
		return m.KnownCard
	}
	return false
}

func (m *RoomConfig) GetTotalNumberOfGame() uint32 {
	if m != nil {
		return m.TotalNumberOfGame
	}
	return 0
}

func (m *RoomConfig) GetKnownRobZhuang() bool {
	if m != nil {
		return m.KnownRobZhuang
	}
	return false
}

func (m *RoomConfig) GetKan() bool {
	if m != nil {
		return m.Kan
	}
	return false
}

func (m *RoomConfig) GetShun() bool {
	if m != nil {
		return m.Shun
	}
	return false
}

func (m *RoomConfig) GetFaster() bool {
	if m != nil {
		return m.Faster
	}
	return false
}

type RoomInfo struct {
	// 房间内当前人数
	PlayerNum uint32 `protobuf:"varint,1,opt,name=playerNum,proto3" json:"playerNum,omitempty"`
	// 房间 id
	RoomId uint32 `protobuf:"varint,2,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 1 是公共房, 2 是私密房
	RoomType             commonProto.RoomType `protobuf:"varint,3,opt,name=roomType,proto3,enum=commonProto.RoomType" json:"roomType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RoomInfo) Reset()         { *m = RoomInfo{} }
func (m *RoomInfo) String() string { return proto.CompactTextString(m) }
func (*RoomInfo) ProtoMessage()    {}
func (*RoomInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{1}
}
func (m *RoomInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoomInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoomInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoomInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoomInfo.Merge(m, src)
}
func (m *RoomInfo) XXX_Size() int {
	return m.Size()
}
func (m *RoomInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RoomInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RoomInfo proto.InternalMessageInfo

func (m *RoomInfo) GetPlayerNum() uint32 {
	if m != nil {
		return m.PlayerNum
	}
	return 0
}

func (m *RoomInfo) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *RoomInfo) GetRoomType() commonProto.RoomType {
	if m != nil {
		return m.RoomType
	}
	return commonProto.RoomType_roomTypeNone
}

type S2CNiuNiuGetAllRoom struct {
	RoomInfos            []*RoomInfo `protobuf:"bytes,1,rep,name=roomInfos,proto3" json:"roomInfos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *S2CNiuNiuGetAllRoom) Reset()         { *m = S2CNiuNiuGetAllRoom{} }
func (m *S2CNiuNiuGetAllRoom) String() string { return proto.CompactTextString(m) }
func (*S2CNiuNiuGetAllRoom) ProtoMessage()    {}
func (*S2CNiuNiuGetAllRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{2}
}
func (m *S2CNiuNiuGetAllRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuNiuGetAllRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuNiuGetAllRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuNiuGetAllRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuNiuGetAllRoom.Merge(m, src)
}
func (m *S2CNiuNiuGetAllRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuNiuGetAllRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuNiuGetAllRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuNiuGetAllRoom proto.InternalMessageInfo

func (m *S2CNiuNiuGetAllRoom) GetRoomInfos() []*RoomInfo {
	if m != nil {
		return m.RoomInfos
	}
	return nil
}

//创建牛牛房间
type C2SCreateNiuniuRoom struct {
	// 房间内人数, [2, 10]
	PlayerNum            uint32   `protobuf:"varint,1,opt,name=playerNum,proto3" json:"playerNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SCreateNiuniuRoom) Reset()         { *m = C2SCreateNiuniuRoom{} }
func (m *C2SCreateNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*C2SCreateNiuniuRoom) ProtoMessage()    {}
func (*C2SCreateNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{3}
}
func (m *C2SCreateNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SCreateNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SCreateNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SCreateNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SCreateNiuniuRoom.Merge(m, src)
}
func (m *C2SCreateNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SCreateNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SCreateNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SCreateNiuniuRoom proto.InternalMessageInfo

func (m *C2SCreateNiuniuRoom) GetPlayerNum() uint32 {
	if m != nil {
		return m.PlayerNum
	}
	return 0
}

type S2CCreateNiuniuRoom struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CCreateNiuniuRoom) Reset()         { *m = S2CCreateNiuniuRoom{} }
func (m *S2CCreateNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*S2CCreateNiuniuRoom) ProtoMessage()    {}
func (*S2CCreateNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{4}
}
func (m *S2CCreateNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CCreateNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CCreateNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CCreateNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CCreateNiuniuRoom.Merge(m, src)
}
func (m *S2CCreateNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CCreateNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CCreateNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CCreateNiuniuRoom proto.InternalMessageInfo

// 获取房间配置
type C2SNiuniuRoomConfig struct {
	RoomIds              []uint32 `protobuf:"varint,1,rep,packed,name=roomIds,proto3" json:"roomIds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SNiuniuRoomConfig) Reset()         { *m = C2SNiuniuRoomConfig{} }
func (m *C2SNiuniuRoomConfig) String() string { return proto.CompactTextString(m) }
func (*C2SNiuniuRoomConfig) ProtoMessage()    {}
func (*C2SNiuniuRoomConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{5}
}
func (m *C2SNiuniuRoomConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SNiuniuRoomConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SNiuniuRoomConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SNiuniuRoomConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SNiuniuRoomConfig.Merge(m, src)
}
func (m *C2SNiuniuRoomConfig) XXX_Size() int {
	return m.Size()
}
func (m *C2SNiuniuRoomConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SNiuniuRoomConfig.DiscardUnknown(m)
}

var xxx_messageInfo_C2SNiuniuRoomConfig proto.InternalMessageInfo

func (m *C2SNiuniuRoomConfig) GetRoomIds() []uint32 {
	if m != nil {
		return m.RoomIds
	}
	return nil
}

type S2CNiuniuRoomConfig struct {
	Cfgs                 []*RoomConfig `protobuf:"bytes,1,rep,name=cfgs,proto3" json:"cfgs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *S2CNiuniuRoomConfig) Reset()         { *m = S2CNiuniuRoomConfig{} }
func (m *S2CNiuniuRoomConfig) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuRoomConfig) ProtoMessage()    {}
func (*S2CNiuniuRoomConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{6}
}
func (m *S2CNiuniuRoomConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuRoomConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuRoomConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuRoomConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuRoomConfig.Merge(m, src)
}
func (m *S2CNiuniuRoomConfig) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuRoomConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuRoomConfig.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuRoomConfig proto.InternalMessageInfo

func (m *S2CNiuniuRoomConfig) GetCfgs() []*RoomConfig {
	if m != nil {
		return m.Cfgs
	}
	return nil
}

// 断线重连时的快照
type ReconnectSnap struct {
	// 已经准备的玩家 uid 列表, 如果当前是准备状态,下面这个字段才有意义
	Prepper []uint32 `protobuf:"varint,1,rep,packed,name=prepper,proto3" json:"prepper,omitempty"`
	// 已经抢庄的玩家列表, uid - 抢庄倍数 如果当前是抢庄状态,下面这个字段才有意义
	MapRobZhuang map[uint32]uint32 `protobuf:"bytes,2,rep,name=mapRobZhuang,proto3" json:"mapRobZhuang,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 自己的4张明牌, 如果当前是抢庄状态,下面这个字段才有意义
	KnownCards []*commonProto.PokerCard `protobuf:"bytes,3,rep,name=knownCards,proto3" json:"knownCards,omitempty"`
	// 正在进行游戏的玩家 uid, 如果当前是抢庄,下注,亮牌,结算状态,下面这个字段才有意义
	PlayerUids []uint32 `protobuf:"varint,4,rep,packed,name=playerUids,proto3" json:"playerUids,omitempty"`
	// 下注信息, uid - 下注倍数, 如果当前是下注, 亮牌, 结算状态,下面这个字段才有意义
	MapBet map[uint32]uint32 `protobuf:"bytes,5,rep,name=mapBet,proto3" json:"mapBet,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 庄家 uid, 如果当前是抢庄,下注,亮牌,结算状态,下面这个字段才有意义
	BankerId uint32 `protobuf:"varint,6,opt,name=bankerId,proto3" json:"bankerId,omitempty"`
	// 亮牌信息, 如果当前是亮牌,结算状态,下面这个字段才有意义
	MapShowCard map[uint32]*S2CNiuniuShowCard `protobuf:"bytes,7,rep,name=mapShowCard,proto3" json:"mapShowCard,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// uid - 输赢金币, 结算状态下,下面这个字段才有意义
	MapWinOrLose map[uint32]int32 `protobuf:"bytes,8,rep,name=mapWinOrLose,proto3" json:"mapWinOrLose,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 自己的第 5 张暗牌
	UnknownCard *commonProto.PokerCard `protobuf:"bytes,9,opt,name=unknownCard,proto3" json:"unknownCard,omitempty"`
	// 每个人身上的金币, uid - gold
	MapPlayerGold        map[uint32]int32 `protobuf:"bytes,10,rep,name=mapPlayerGold,proto3" json:"mapPlayerGold,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ReconnectSnap) Reset()         { *m = ReconnectSnap{} }
func (m *ReconnectSnap) String() string { return proto.CompactTextString(m) }
func (*ReconnectSnap) ProtoMessage()    {}
func (*ReconnectSnap) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{7}
}
func (m *ReconnectSnap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReconnectSnap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReconnectSnap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReconnectSnap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReconnectSnap.Merge(m, src)
}
func (m *ReconnectSnap) XXX_Size() int {
	return m.Size()
}
func (m *ReconnectSnap) XXX_DiscardUnknown() {
	xxx_messageInfo_ReconnectSnap.DiscardUnknown(m)
}

var xxx_messageInfo_ReconnectSnap proto.InternalMessageInfo

func (m *ReconnectSnap) GetPrepper() []uint32 {
	if m != nil {
		return m.Prepper
	}
	return nil
}

func (m *ReconnectSnap) GetMapRobZhuang() map[uint32]uint32 {
	if m != nil {
		return m.MapRobZhuang
	}
	return nil
}

func (m *ReconnectSnap) GetKnownCards() []*commonProto.PokerCard {
	if m != nil {
		return m.KnownCards
	}
	return nil
}

func (m *ReconnectSnap) GetPlayerUids() []uint32 {
	if m != nil {
		return m.PlayerUids
	}
	return nil
}

func (m *ReconnectSnap) GetMapBet() map[uint32]uint32 {
	if m != nil {
		return m.MapBet
	}
	return nil
}

func (m *ReconnectSnap) GetBankerId() uint32 {
	if m != nil {
		return m.BankerId
	}
	return 0
}

func (m *ReconnectSnap) GetMapShowCard() map[uint32]*S2CNiuniuShowCard {
	if m != nil {
		return m.MapShowCard
	}
	return nil
}

func (m *ReconnectSnap) GetMapWinOrLose() map[uint32]int32 {
	if m != nil {
		return m.MapWinOrLose
	}
	return nil
}

func (m *ReconnectSnap) GetUnknownCard() *commonProto.PokerCard {
	if m != nil {
		return m.UnknownCard
	}
	return nil
}

func (m *ReconnectSnap) GetMapPlayerGold() map[uint32]int32 {
	if m != nil {
		return m.MapPlayerGold
	}
	return nil
}

// 进入牛牛房间
type C2SEnterNiuniuRoom struct {
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 这个值是服务器填写
	Uid uint32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// 这个值是服务器填写
	Wxid                 string   `protobuf:"bytes,3,opt,name=wxid,proto3" json:"wxid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SEnterNiuniuRoom) Reset()         { *m = C2SEnterNiuniuRoom{} }
func (m *C2SEnterNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*C2SEnterNiuniuRoom) ProtoMessage()    {}
func (*C2SEnterNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{8}
}
func (m *C2SEnterNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SEnterNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SEnterNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SEnterNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SEnterNiuniuRoom.Merge(m, src)
}
func (m *C2SEnterNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SEnterNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SEnterNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SEnterNiuniuRoom proto.InternalMessageInfo

func (m *C2SEnterNiuniuRoom) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *C2SEnterNiuniuRoom) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *C2SEnterNiuniuRoom) GetWxid() string {
	if m != nil {
		return m.Wxid
	}
	return ""
}

type Lobby2GateEnterNiuniuRoom struct {
	C2SEnterNiuniuRoom   []byte   `protobuf:"bytes,1,opt,name=c2sEnterNiuniuRoom,proto3" json:"c2sEnterNiuniuRoom,omitempty"`
	NiuniuServerId       uint32   `protobuf:"varint,2,opt,name=niuniuServerId,proto3" json:"niuniuServerId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Lobby2GateEnterNiuniuRoom) Reset()         { *m = Lobby2GateEnterNiuniuRoom{} }
func (m *Lobby2GateEnterNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*Lobby2GateEnterNiuniuRoom) ProtoMessage()    {}
func (*Lobby2GateEnterNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{9}
}
func (m *Lobby2GateEnterNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lobby2GateEnterNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Lobby2GateEnterNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Lobby2GateEnterNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lobby2GateEnterNiuniuRoom.Merge(m, src)
}
func (m *Lobby2GateEnterNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *Lobby2GateEnterNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_Lobby2GateEnterNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_Lobby2GateEnterNiuniuRoom proto.InternalMessageInfo

func (m *Lobby2GateEnterNiuniuRoom) GetC2SEnterNiuniuRoom() []byte {
	if m != nil {
		return m.C2SEnterNiuniuRoom
	}
	return nil
}

func (m *Lobby2GateEnterNiuniuRoom) GetNiuniuServerId() uint32 {
	if m != nil {
		return m.NiuniuServerId
	}
	return 0
}

type S2CEnterNiuniuRoom struct {
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 座位号 - playerBaseInfo
	MapPlayerBaseInfo map[uint32]*commonProto.PlayerBaseInfo `protobuf:"bytes,2,rep,name=mapPlayerBaseInfo,proto3" json:"mapPlayerBaseInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 玩家本人的基本信息
	PlayerBaseInfo *commonProto.PlayerBaseInfo `protobuf:"bytes,3,opt,name=playerBaseInfo,proto3" json:"playerBaseInfo,omitempty"`
	// 当前的房间状态
	RoomStatus NiuniuRoomStatus `protobuf:"varint,4,opt,name=roomStatus,proto3,enum=niuniuProto.NiuniuRoomStatus" json:"roomStatus,omitempty"`
	// 旁观者数量
	BystanderNum uint32 `protobuf:"varint,5,opt,name=bystanderNum,proto3" json:"bystanderNum,omitempty"`
	// 当前房间状态倒计时
	CountDown uint32 `protobuf:"varint,6,opt,name=countDown,proto3" json:"countDown,omitempty"`
	// 下面这个字段是断线重连用的
	RcSnap *ReconnectSnap `protobuf:"bytes,7,opt,name=rcSnap,proto3" json:"rcSnap,omitempty"`
	//房间配置信息
	Config *RoomConfig `protobuf:"bytes,8,opt,name=config,proto3" json:"config,omitempty"`
	//当前局数
	NumberOfGame uint32 `protobuf:"varint,9,opt,name=numberOfGame,proto3" json:"numberOfGame,omitempty"`
	//房主,玩家uid
	Owner                uint32   `protobuf:"varint,10,opt,name=owner,proto3" json:"owner,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CEnterNiuniuRoom) Reset()         { *m = S2CEnterNiuniuRoom{} }
func (m *S2CEnterNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*S2CEnterNiuniuRoom) ProtoMessage()    {}
func (*S2CEnterNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{10}
}
func (m *S2CEnterNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CEnterNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CEnterNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CEnterNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CEnterNiuniuRoom.Merge(m, src)
}
func (m *S2CEnterNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CEnterNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CEnterNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CEnterNiuniuRoom proto.InternalMessageInfo

func (m *S2CEnterNiuniuRoom) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CEnterNiuniuRoom) GetMapPlayerBaseInfo() map[uint32]*commonProto.PlayerBaseInfo {
	if m != nil {
		return m.MapPlayerBaseInfo
	}
	return nil
}

func (m *S2CEnterNiuniuRoom) GetPlayerBaseInfo() *commonProto.PlayerBaseInfo {
	if m != nil {
		return m.PlayerBaseInfo
	}
	return nil
}

func (m *S2CEnterNiuniuRoom) GetRoomStatus() NiuniuRoomStatus {
	if m != nil {
		return m.RoomStatus
	}
	return NiuniuRoomStatus_niuniuRoomStatusNone
}

func (m *S2CEnterNiuniuRoom) GetBystanderNum() uint32 {
	if m != nil {
		return m.BystanderNum
	}
	return 0
}

func (m *S2CEnterNiuniuRoom) GetCountDown() uint32 {
	if m != nil {
		return m.CountDown
	}
	return 0
}

func (m *S2CEnterNiuniuRoom) GetRcSnap() *ReconnectSnap {
	if m != nil {
		return m.RcSnap
	}
	return nil
}

func (m *S2CEnterNiuniuRoom) GetConfig() *RoomConfig {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *S2CEnterNiuniuRoom) GetNumberOfGame() uint32 {
	if m != nil {
		return m.NumberOfGame
	}
	return 0
}

func (m *S2CEnterNiuniuRoom) GetOwner() uint32 {
	if m != nil {
		return m.Owner
	}
	return 0
}

// 通知用户,有其他人进入牛牛房间
type S2COtherPlayerEnterNiuniuRoom struct {
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 旁观者数量
	BystanderNum         uint32   `protobuf:"varint,2,opt,name=bystanderNum,proto3" json:"bystanderNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2COtherPlayerEnterNiuniuRoom) Reset()         { *m = S2COtherPlayerEnterNiuniuRoom{} }
func (m *S2COtherPlayerEnterNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*S2COtherPlayerEnterNiuniuRoom) ProtoMessage()    {}
func (*S2COtherPlayerEnterNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{11}
}
func (m *S2COtherPlayerEnterNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2COtherPlayerEnterNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2COtherPlayerEnterNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2COtherPlayerEnterNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2COtherPlayerEnterNiuniuRoom.Merge(m, src)
}
func (m *S2COtherPlayerEnterNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2COtherPlayerEnterNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2COtherPlayerEnterNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2COtherPlayerEnterNiuniuRoom proto.InternalMessageInfo

func (m *S2COtherPlayerEnterNiuniuRoom) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2COtherPlayerEnterNiuniuRoom) GetBystanderNum() uint32 {
	if m != nil {
		return m.BystanderNum
	}
	return 0
}

// 离开牛牛房间
type C2SLeaveNiuniuRoom struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SLeaveNiuniuRoom) Reset()         { *m = C2SLeaveNiuniuRoom{} }
func (m *C2SLeaveNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*C2SLeaveNiuniuRoom) ProtoMessage()    {}
func (*C2SLeaveNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{12}
}
func (m *C2SLeaveNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SLeaveNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SLeaveNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SLeaveNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SLeaveNiuniuRoom.Merge(m, src)
}
func (m *C2SLeaveNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SLeaveNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SLeaveNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SLeaveNiuniuRoom proto.InternalMessageInfo

type S2CLeaveNiuniuRoom struct {
	RoomId               uint32   `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CLeaveNiuniuRoom) Reset()         { *m = S2CLeaveNiuniuRoom{} }
func (m *S2CLeaveNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*S2CLeaveNiuniuRoom) ProtoMessage()    {}
func (*S2CLeaveNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{13}
}
func (m *S2CLeaveNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CLeaveNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CLeaveNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CLeaveNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CLeaveNiuniuRoom.Merge(m, src)
}
func (m *S2CLeaveNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CLeaveNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CLeaveNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CLeaveNiuniuRoom proto.InternalMessageInfo

func (m *S2CLeaveNiuniuRoom) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

// 离开房间后,广播
type S2CBroadcastLeaveNiuniuRoom struct {
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 旁观者数量
	BystanderNum uint32 `protobuf:"varint,2,opt,name=bystanderNum,proto3" json:"bystanderNum,omitempty"`
	// 座位号, 如果没有在座位上, seatIndex = -1
	SeatIndex            int32    `protobuf:"varint,3,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CBroadcastLeaveNiuniuRoom) Reset()         { *m = S2CBroadcastLeaveNiuniuRoom{} }
func (m *S2CBroadcastLeaveNiuniuRoom) String() string { return proto.CompactTextString(m) }
func (*S2CBroadcastLeaveNiuniuRoom) ProtoMessage()    {}
func (*S2CBroadcastLeaveNiuniuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{14}
}
func (m *S2CBroadcastLeaveNiuniuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CBroadcastLeaveNiuniuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CBroadcastLeaveNiuniuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CBroadcastLeaveNiuniuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CBroadcastLeaveNiuniuRoom.Merge(m, src)
}
func (m *S2CBroadcastLeaveNiuniuRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CBroadcastLeaveNiuniuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CBroadcastLeaveNiuniuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CBroadcastLeaveNiuniuRoom proto.InternalMessageInfo

func (m *S2CBroadcastLeaveNiuniuRoom) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CBroadcastLeaveNiuniuRoom) GetBystanderNum() uint32 {
	if m != nil {
		return m.BystanderNum
	}
	return 0
}

func (m *S2CBroadcastLeaveNiuniuRoom) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

// 牛牛房间内的客户端断线通知
type S2CNiuniuClientDisconnect struct {
	RoomId               uint32   `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	SeatIndex            int32    `protobuf:"varint,2,opt,name=seatIndex,proto3" json:"seatIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuClientDisconnect) Reset()         { *m = S2CNiuniuClientDisconnect{} }
func (m *S2CNiuniuClientDisconnect) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuClientDisconnect) ProtoMessage()    {}
func (*S2CNiuniuClientDisconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{15}
}
func (m *S2CNiuniuClientDisconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuClientDisconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuClientDisconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuClientDisconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuClientDisconnect.Merge(m, src)
}
func (m *S2CNiuniuClientDisconnect) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuClientDisconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuClientDisconnect.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuClientDisconnect proto.InternalMessageInfo

func (m *S2CNiuniuClientDisconnect) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CNiuniuClientDisconnect) GetSeatIndex() int32 {
	if m != nil {
		return m.SeatIndex
	}
	return 0
}

type S2CNiuniuBroadcastRoomStatus struct {
	RoomStatus NiuniuRoomStatus `protobuf:"varint,1,opt,name=roomStatus,proto3,enum=niuniuProto.NiuniuRoomStatus" json:"roomStatus,omitempty"`
	// 倒计时
	CountDown            uint32   `protobuf:"varint,2,opt,name=countDown,proto3" json:"countDown,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuBroadcastRoomStatus) Reset()         { *m = S2CNiuniuBroadcastRoomStatus{} }
func (m *S2CNiuniuBroadcastRoomStatus) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuBroadcastRoomStatus) ProtoMessage()    {}
func (*S2CNiuniuBroadcastRoomStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{16}
}
func (m *S2CNiuniuBroadcastRoomStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuBroadcastRoomStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuBroadcastRoomStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuBroadcastRoomStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuBroadcastRoomStatus.Merge(m, src)
}
func (m *S2CNiuniuBroadcastRoomStatus) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuBroadcastRoomStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuBroadcastRoomStatus.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuBroadcastRoomStatus proto.InternalMessageInfo

func (m *S2CNiuniuBroadcastRoomStatus) GetRoomStatus() NiuniuRoomStatus {
	if m != nil {
		return m.RoomStatus
	}
	return NiuniuRoomStatus_niuniuRoomStatusNone
}

func (m *S2CNiuniuBroadcastRoomStatus) GetCountDown() uint32 {
	if m != nil {
		return m.CountDown
	}
	return 0
}

type C2SNiuniuReady struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SNiuniuReady) Reset()         { *m = C2SNiuniuReady{} }
func (m *C2SNiuniuReady) String() string { return proto.CompactTextString(m) }
func (*C2SNiuniuReady) ProtoMessage()    {}
func (*C2SNiuniuReady) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{17}
}
func (m *C2SNiuniuReady) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SNiuniuReady) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SNiuniuReady.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SNiuniuReady) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SNiuniuReady.Merge(m, src)
}
func (m *C2SNiuniuReady) XXX_Size() int {
	return m.Size()
}
func (m *C2SNiuniuReady) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SNiuniuReady.DiscardUnknown(m)
}

var xxx_messageInfo_C2SNiuniuReady proto.InternalMessageInfo

type S2CNiuniuReady struct {
	// 准备者的 id
	Uid uint32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// 旁观者数量
	BystanderNum         uint32   `protobuf:"varint,2,opt,name=bystanderNum,proto3" json:"bystanderNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuReady) Reset()         { *m = S2CNiuniuReady{} }
func (m *S2CNiuniuReady) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuReady) ProtoMessage()    {}
func (*S2CNiuniuReady) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{18}
}
func (m *S2CNiuniuReady) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuReady) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuReady.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuReady) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuReady.Merge(m, src)
}
func (m *S2CNiuniuReady) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuReady) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuReady.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuReady proto.InternalMessageInfo

func (m *S2CNiuniuReady) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *S2CNiuniuReady) GetBystanderNum() uint32 {
	if m != nil {
		return m.BystanderNum
	}
	return 0
}

// 发明牌
type S2CNiuniuSendKnownCard struct {
	Cards                []*commonProto.PokerCard `protobuf:"bytes,1,rep,name=cards,proto3" json:"cards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *S2CNiuniuSendKnownCard) Reset()         { *m = S2CNiuniuSendKnownCard{} }
func (m *S2CNiuniuSendKnownCard) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuSendKnownCard) ProtoMessage()    {}
func (*S2CNiuniuSendKnownCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{19}
}
func (m *S2CNiuniuSendKnownCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuSendKnownCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuSendKnownCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuSendKnownCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuSendKnownCard.Merge(m, src)
}
func (m *S2CNiuniuSendKnownCard) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuSendKnownCard) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuSendKnownCard.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuSendKnownCard proto.InternalMessageInfo

func (m *S2CNiuniuSendKnownCard) GetCards() []*commonProto.PokerCard {
	if m != nil {
		return m.Cards
	}
	return nil
}

type C2SNiuniuRobZhuang struct {
	// 抢庄的倍率, 0 不抢庄, 1,2,3,4 倍率
	Rate                 uint32   `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SNiuniuRobZhuang) Reset()         { *m = C2SNiuniuRobZhuang{} }
func (m *C2SNiuniuRobZhuang) String() string { return proto.CompactTextString(m) }
func (*C2SNiuniuRobZhuang) ProtoMessage()    {}
func (*C2SNiuniuRobZhuang) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{20}
}
func (m *C2SNiuniuRobZhuang) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SNiuniuRobZhuang) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SNiuniuRobZhuang.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SNiuniuRobZhuang) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SNiuniuRobZhuang.Merge(m, src)
}
func (m *C2SNiuniuRobZhuang) XXX_Size() int {
	return m.Size()
}
func (m *C2SNiuniuRobZhuang) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SNiuniuRobZhuang.DiscardUnknown(m)
}

var xxx_messageInfo_C2SNiuniuRobZhuang proto.InternalMessageInfo

func (m *C2SNiuniuRobZhuang) GetRate() uint32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

type S2CNiuniuRobZhuang struct {
	// 服务器对抢庄确认, 0 不抢庄, 1,2,3,4 倍率
	Rate uint32 `protobuf:"varint,1,opt,name=rate,proto3" json:"rate,omitempty"`
	// 抢庄者 id
	Uid                  uint32   `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuRobZhuang) Reset()         { *m = S2CNiuniuRobZhuang{} }
func (m *S2CNiuniuRobZhuang) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuRobZhuang) ProtoMessage()    {}
func (*S2CNiuniuRobZhuang) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{21}
}
func (m *S2CNiuniuRobZhuang) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuRobZhuang) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuRobZhuang.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuRobZhuang) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuRobZhuang.Merge(m, src)
}
func (m *S2CNiuniuRobZhuang) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuRobZhuang) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuRobZhuang.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuRobZhuang proto.InternalMessageInfo

func (m *S2CNiuniuRobZhuang) GetRate() uint32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

func (m *S2CNiuniuRobZhuang) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 定庄
type S2CConfirmBanker struct {
	Uid  uint32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Rate uint32 `protobuf:"varint,2,opt,name=rate,proto3" json:"rate,omitempty"`
	// 相同倍率的 uid
	Uids                 []uint32 `protobuf:"varint,3,rep,packed,name=uids,proto3" json:"uids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CConfirmBanker) Reset()         { *m = S2CConfirmBanker{} }
func (m *S2CConfirmBanker) String() string { return proto.CompactTextString(m) }
func (*S2CConfirmBanker) ProtoMessage()    {}
func (*S2CConfirmBanker) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{22}
}
func (m *S2CConfirmBanker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CConfirmBanker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CConfirmBanker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CConfirmBanker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CConfirmBanker.Merge(m, src)
}
func (m *S2CConfirmBanker) XXX_Size() int {
	return m.Size()
}
func (m *S2CConfirmBanker) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CConfirmBanker.DiscardUnknown(m)
}

var xxx_messageInfo_S2CConfirmBanker proto.InternalMessageInfo

func (m *S2CConfirmBanker) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *S2CConfirmBanker) GetRate() uint32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

func (m *S2CConfirmBanker) GetUids() []uint32 {
	if m != nil {
		return m.Uids
	}
	return nil
}

// 下注
type C2SNiuniuBet struct {
	Bet                  uint32   `protobuf:"varint,1,opt,name=bet,proto3" json:"bet,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SNiuniuBet) Reset()         { *m = C2SNiuniuBet{} }
func (m *C2SNiuniuBet) String() string { return proto.CompactTextString(m) }
func (*C2SNiuniuBet) ProtoMessage()    {}
func (*C2SNiuniuBet) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{23}
}
func (m *C2SNiuniuBet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SNiuniuBet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SNiuniuBet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SNiuniuBet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SNiuniuBet.Merge(m, src)
}
func (m *C2SNiuniuBet) XXX_Size() int {
	return m.Size()
}
func (m *C2SNiuniuBet) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SNiuniuBet.DiscardUnknown(m)
}

var xxx_messageInfo_C2SNiuniuBet proto.InternalMessageInfo

func (m *C2SNiuniuBet) GetBet() uint32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

type S2CNiuniuBet struct {
	Bet                  uint32   `protobuf:"varint,1,opt,name=bet,proto3" json:"bet,omitempty"`
	Uid                  uint32   `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuBet) Reset()         { *m = S2CNiuniuBet{} }
func (m *S2CNiuniuBet) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuBet) ProtoMessage()    {}
func (*S2CNiuniuBet) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{24}
}
func (m *S2CNiuniuBet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuBet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuBet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuBet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuBet.Merge(m, src)
}
func (m *S2CNiuniuBet) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuBet) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuBet.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuBet proto.InternalMessageInfo

func (m *S2CNiuniuBet) GetBet() uint32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *S2CNiuniuBet) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 发一张暗牌
type S2CNiuniuSendOneUnknownCard struct {
	Card                 *commonProto.PokerCard `protobuf:"bytes,1,opt,name=card,proto3" json:"card,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *S2CNiuniuSendOneUnknownCard) Reset()         { *m = S2CNiuniuSendOneUnknownCard{} }
func (m *S2CNiuniuSendOneUnknownCard) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuSendOneUnknownCard) ProtoMessage()    {}
func (*S2CNiuniuSendOneUnknownCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{25}
}
func (m *S2CNiuniuSendOneUnknownCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuSendOneUnknownCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuSendOneUnknownCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuSendOneUnknownCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuSendOneUnknownCard.Merge(m, src)
}
func (m *S2CNiuniuSendOneUnknownCard) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuSendOneUnknownCard) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuSendOneUnknownCard.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuSendOneUnknownCard proto.InternalMessageInfo

func (m *S2CNiuniuSendOneUnknownCard) GetCard() *commonProto.PokerCard {
	if m != nil {
		return m.Card
	}
	return nil
}

type C2SNiuniuShowCard struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SNiuniuShowCard) Reset()         { *m = C2SNiuniuShowCard{} }
func (m *C2SNiuniuShowCard) String() string { return proto.CompactTextString(m) }
func (*C2SNiuniuShowCard) ProtoMessage()    {}
func (*C2SNiuniuShowCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{26}
}
func (m *C2SNiuniuShowCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SNiuniuShowCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SNiuniuShowCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SNiuniuShowCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SNiuniuShowCard.Merge(m, src)
}
func (m *C2SNiuniuShowCard) XXX_Size() int {
	return m.Size()
}
func (m *C2SNiuniuShowCard) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SNiuniuShowCard.DiscardUnknown(m)
}

var xxx_messageInfo_C2SNiuniuShowCard proto.InternalMessageInfo

type S2CNiuniuShowCard struct {
	Uid uint32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// 手中牌
	Cards []*commonProto.PokerCard `protobuf:"bytes,2,rep,name=cards,proto3" json:"cards,omitempty"`
	// 牌型( 无牛, 牛1, ...牛牛, 其他特殊牌型 )
	CardType uint32 `protobuf:"varint,3,opt,name=cardType,proto3" json:"cardType,omitempty"`
	// 牌型组合
	CardComb             []*commonProto.PokerCard `protobuf:"bytes,4,rep,name=cardComb,proto3" json:"cardComb,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *S2CNiuniuShowCard) Reset()         { *m = S2CNiuniuShowCard{} }
func (m *S2CNiuniuShowCard) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuShowCard) ProtoMessage()    {}
func (*S2CNiuniuShowCard) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{27}
}
func (m *S2CNiuniuShowCard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuShowCard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuShowCard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuShowCard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuShowCard.Merge(m, src)
}
func (m *S2CNiuniuShowCard) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuShowCard) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuShowCard.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuShowCard proto.InternalMessageInfo

func (m *S2CNiuniuShowCard) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *S2CNiuniuShowCard) GetCards() []*commonProto.PokerCard {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *S2CNiuniuShowCard) GetCardType() uint32 {
	if m != nil {
		return m.CardType
	}
	return 0
}

func (m *S2CNiuniuShowCard) GetCardComb() []*commonProto.PokerCard {
	if m != nil {
		return m.CardComb
	}
	return nil
}

type S2CNiuniuSettle struct {
	// uid - 实际输赢金币
	MapWinOrLose map[uint32]int32 `protobuf:"bytes,1,rep,name=mapWinOrLose,proto3" json:"mapWinOrLose,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// uid - 剩余金币
	MapPlayerGold map[uint32]int32 `protobuf:"bytes,2,rep,name=mapPlayerGold,proto3" json:"mapPlayerGold,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 对 mapWinOrLose  扣除了房费的结果
	MapWinOrLoseFinal    map[uint32]int32 `protobuf:"bytes,3,rep,name=mapWinOrLoseFinal,proto3" json:"mapWinOrLoseFinal,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *S2CNiuniuSettle) Reset()         { *m = S2CNiuniuSettle{} }
func (m *S2CNiuniuSettle) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuSettle) ProtoMessage()    {}
func (*S2CNiuniuSettle) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{28}
}
func (m *S2CNiuniuSettle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuSettle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuSettle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuSettle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuSettle.Merge(m, src)
}
func (m *S2CNiuniuSettle) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuSettle) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuSettle.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuSettle proto.InternalMessageInfo

func (m *S2CNiuniuSettle) GetMapWinOrLose() map[uint32]int32 {
	if m != nil {
		return m.MapWinOrLose
	}
	return nil
}

func (m *S2CNiuniuSettle) GetMapPlayerGold() map[uint32]int32 {
	if m != nil {
		return m.MapPlayerGold
	}
	return nil
}

func (m *S2CNiuniuSettle) GetMapWinOrLoseFinal() map[uint32]int32 {
	if m != nil {
		return m.MapWinOrLoseFinal
	}
	return nil
}

// 入座回复
type S2CNiuniuHaveASeat struct {
	// 座位号, 只有当 isSitDown == true 时, 此字段才有意义
	SeatIdx uint32 `protobuf:"varint,1,opt,name=seatIdx,proto3" json:"seatIdx,omitempty"`
	// 入座成功; true 表示从旁观者成功入座
	IsSitDown bool `protobuf:"varint,2,opt,name=isSitDown,proto3" json:"isSitDown,omitempty"`
	// 旁观者数量, 只有当 isSitDown == true 时, 此字段才有意义
	BystanderNum uint32 `protobuf:"varint,3,opt,name=bystanderNum,proto3" json:"bystanderNum,omitempty"`
	// 入座者信息, 只有当 isSitDown == true 时, 此字段才有意义
	Player               *commonProto.PlayerBaseInfo `protobuf:"bytes,4,opt,name=player,proto3" json:"player,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *S2CNiuniuHaveASeat) Reset()         { *m = S2CNiuniuHaveASeat{} }
func (m *S2CNiuniuHaveASeat) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuHaveASeat) ProtoMessage()    {}
func (*S2CNiuniuHaveASeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{29}
}
func (m *S2CNiuniuHaveASeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuHaveASeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuHaveASeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuHaveASeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuHaveASeat.Merge(m, src)
}
func (m *S2CNiuniuHaveASeat) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuHaveASeat) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuHaveASeat.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuHaveASeat proto.InternalMessageInfo

func (m *S2CNiuniuHaveASeat) GetSeatIdx() uint32 {
	if m != nil {
		return m.SeatIdx
	}
	return 0
}

func (m *S2CNiuniuHaveASeat) GetIsSitDown() bool {
	if m != nil {
		return m.IsSitDown
	}
	return false
}

func (m *S2CNiuniuHaveASeat) GetBystanderNum() uint32 {
	if m != nil {
		return m.BystanderNum
	}
	return 0
}

func (m *S2CNiuniuHaveASeat) GetPlayer() *commonProto.PlayerBaseInfo {
	if m != nil {
		return m.Player
	}
	return nil
}

// 离开座位回复
type S2CNiuniuLeaveTheSeat struct {
	// 离开座位的人, uid - 座位号, [0, 10]
	MapUidSeat map[uint32]uint32 `protobuf:"bytes,1,rep,name=mapUidSeat,proto3" json:"mapUidSeat,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 旁观者数量
	BystanderNum         uint32   `protobuf:"varint,2,opt,name=bystanderNum,proto3" json:"bystanderNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuLeaveTheSeat) Reset()         { *m = S2CNiuniuLeaveTheSeat{} }
func (m *S2CNiuniuLeaveTheSeat) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuLeaveTheSeat) ProtoMessage()    {}
func (*S2CNiuniuLeaveTheSeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{30}
}
func (m *S2CNiuniuLeaveTheSeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuLeaveTheSeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuLeaveTheSeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuLeaveTheSeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuLeaveTheSeat.Merge(m, src)
}
func (m *S2CNiuniuLeaveTheSeat) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuLeaveTheSeat) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuLeaveTheSeat.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuLeaveTheSeat proto.InternalMessageInfo

func (m *S2CNiuniuLeaveTheSeat) GetMapUidSeat() map[uint32]uint32 {
	if m != nil {
		return m.MapUidSeat
	}
	return nil
}

func (m *S2CNiuniuLeaveTheSeat) GetBystanderNum() uint32 {
	if m != nil {
		return m.BystanderNum
	}
	return 0
}

type C2SNiuniuPing struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SNiuniuPing) Reset()         { *m = C2SNiuniuPing{} }
func (m *C2SNiuniuPing) String() string { return proto.CompactTextString(m) }
func (*C2SNiuniuPing) ProtoMessage()    {}
func (*C2SNiuniuPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{31}
}
func (m *C2SNiuniuPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SNiuniuPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SNiuniuPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SNiuniuPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SNiuniuPing.Merge(m, src)
}
func (m *C2SNiuniuPing) XXX_Size() int {
	return m.Size()
}
func (m *C2SNiuniuPing) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SNiuniuPing.DiscardUnknown(m)
}

var xxx_messageInfo_C2SNiuniuPing proto.InternalMessageInfo

func (m *C2SNiuniuPing) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type S2CNiuniuPong struct {
	Timestamp            int64    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuPong) Reset()         { *m = S2CNiuniuPong{} }
func (m *S2CNiuniuPong) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuPong) ProtoMessage()    {}
func (*S2CNiuniuPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{32}
}
func (m *S2CNiuniuPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuPong.Merge(m, src)
}
func (m *S2CNiuniuPong) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuPong) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuPong.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuPong proto.InternalMessageInfo

func (m *S2CNiuniuPong) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

//自建牛牛房
type C2SSelfBuildNiuNiuRoom struct {
	//玩法 1:名牌抢庄 2:暗牌抢庄
	PlayingMethod int32 `protobuf:"varint,1,opt,name=playingMethod,proto3" json:"playingMethod,omitempty"`
	//底分类型 1：经典 2：趣味
	LowGradeType int32 `protobuf:"varint,2,opt,name=lowGradeType,proto3" json:"lowGradeType,omitempty"`
	//底分值 先写死，后期后端接口控制 使用数组下标
	LowGrade int32 `protobuf:"varint,3,opt,name=lowGrade,proto3" json:"lowGrade,omitempty"`
	//局数 10 20 30  0为永久
	NumberOfGame int32 `protobuf:"varint,4,opt,name=numberOfGame,proto3" json:"numberOfGame,omitempty"`
	//翻倍规则 方案1：牛牛*4，牛九*3，牛八*2，牛七*2  方案2：牛牛*3，牛九*2，牛八*2，牛七*2 方案3：牛牛*3，牛九*2，牛八*2 方案4：有番牛
	DoubleRules int32 `protobuf:"varint,5,opt,name=doubleRules,proto3" json:"doubleRules,omitempty"`
	//特殊牌翻倍规则 1：方案1  2：方案2
	SpecialDoubleRules int32 `protobuf:"varint,6,opt,name=specialDoubleRules,proto3" json:"specialDoubleRules,omitempty"`
	//最大抢庄 1 2 3 4 倍
	TheBiggestRobZhuang int32 `protobuf:"varint,7,opt,name=theBiggestRobZhuang,proto3" json:"theBiggestRobZhuang,omitempty"`
	//闲家推注 无 5 10 15 20 50 倍
	PlayerPushNumber int32 `protobuf:"varint,8,opt,name=PlayerPushNumber,proto3" json:"PlayerPushNumber,omitempty"`
	//玩家数量 4 6 8 10
	PlayerNumber uint32 `protobuf:"varint,9,opt,name=playerNumber,proto3" json:"playerNumber,omitempty"`
	//是否允许中途加入 0:不允许 1:允许
	Add int32 `protobuf:"varint,10,opt,name=add,proto3" json:"add,omitempty"`
	//急速模式
	TheShoot int32 `protobuf:"varint,11,opt,name=theShoot,proto3" json:"theShoot,omitempty"`
	//下注加倍
	DoubleBottomPour int32 `protobuf:"varint,12,opt,name=doubleBottomPour,proto3" json:"doubleBottomPour,omitempty"`
	//买马
	BuyHorse int32 `protobuf:"varint,13,opt,name=buyHorse,proto3" json:"buyHorse,omitempty"`
	//下注限制
	BetLimit int32 `protobuf:"varint,14,opt,name=betLimit,proto3" json:"betLimit,omitempty"`
	//暗抢庄家
	DarkGrabBanker int32 `protobuf:"varint,15,opt,name=darkGrabBanker,proto3" json:"darkGrabBanker,omitempty"`
	//无花牌
	FaceCards int32 `protobuf:"varint,16,opt,name=faceCards,proto3" json:"faceCards,omitempty"`
	//王赖王法
	KingLaiKingOf int32 `protobuf:"varint,17,opt,name=kingLaiKingOf,proto3" json:"kingLaiKingOf,omitempty"`
	//坎斗
	HeFights int32 `protobuf:"varint,18,opt,name=heFights,proto3" json:"heFights,omitempty"`
	//顺斗
	AlongTheBucket int32 `protobuf:"varint,19,opt,name=alongTheBucket,proto3" json:"alongTheBucket,omitempty"`
	//房间公开
	RoomPublic int32 `protobuf:"varint,20,opt,name=roomPublic,proto3" json:"roomPublic,omitempty"`
	//房费 金币自建房无房费 1:房主支付 2:AA
	RoomRate             int32    `protobuf:"varint,21,opt,name=roomRate,proto3" json:"roomRate,omitempty"`
	Uid                  uint32   `protobuf:"varint,22,opt,name=uid,proto3" json:"uid,omitempty"`
	Wxid                 string   `protobuf:"bytes,23,opt,name=wxid,proto3" json:"wxid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2SSelfBuildNiuNiuRoom) Reset()         { *m = C2SSelfBuildNiuNiuRoom{} }
func (m *C2SSelfBuildNiuNiuRoom) String() string { return proto.CompactTextString(m) }
func (*C2SSelfBuildNiuNiuRoom) ProtoMessage()    {}
func (*C2SSelfBuildNiuNiuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{33}
}
func (m *C2SSelfBuildNiuNiuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *C2SSelfBuildNiuNiuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_C2SSelfBuildNiuNiuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *C2SSelfBuildNiuNiuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2SSelfBuildNiuNiuRoom.Merge(m, src)
}
func (m *C2SSelfBuildNiuNiuRoom) XXX_Size() int {
	return m.Size()
}
func (m *C2SSelfBuildNiuNiuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_C2SSelfBuildNiuNiuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_C2SSelfBuildNiuNiuRoom proto.InternalMessageInfo

func (m *C2SSelfBuildNiuNiuRoom) GetPlayingMethod() int32 {
	if m != nil {
		return m.PlayingMethod
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetLowGradeType() int32 {
	if m != nil {
		return m.LowGradeType
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetLowGrade() int32 {
	if m != nil {
		return m.LowGrade
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetNumberOfGame() int32 {
	if m != nil {
		return m.NumberOfGame
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetDoubleRules() int32 {
	if m != nil {
		return m.DoubleRules
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetSpecialDoubleRules() int32 {
	if m != nil {
		return m.SpecialDoubleRules
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetTheBiggestRobZhuang() int32 {
	if m != nil {
		return m.TheBiggestRobZhuang
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetPlayerPushNumber() int32 {
	if m != nil {
		return m.PlayerPushNumber
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetPlayerNumber() uint32 {
	if m != nil {
		return m.PlayerNumber
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetAdd() int32 {
	if m != nil {
		return m.Add
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetTheShoot() int32 {
	if m != nil {
		return m.TheShoot
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetDoubleBottomPour() int32 {
	if m != nil {
		return m.DoubleBottomPour
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetBuyHorse() int32 {
	if m != nil {
		return m.BuyHorse
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetBetLimit() int32 {
	if m != nil {
		return m.BetLimit
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetDarkGrabBanker() int32 {
	if m != nil {
		return m.DarkGrabBanker
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetFaceCards() int32 {
	if m != nil {
		return m.FaceCards
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetKingLaiKingOf() int32 {
	if m != nil {
		return m.KingLaiKingOf
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetHeFights() int32 {
	if m != nil {
		return m.HeFights
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetAlongTheBucket() int32 {
	if m != nil {
		return m.AlongTheBucket
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetRoomPublic() int32 {
	if m != nil {
		return m.RoomPublic
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetRoomRate() int32 {
	if m != nil {
		return m.RoomRate
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetUid() uint32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *C2SSelfBuildNiuNiuRoom) GetWxid() string {
	if m != nil {
		return m.Wxid
	}
	return ""
}

type S2CSelfBuildNiuNiuRoom struct {
	// 房间 id
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	// 底分
	BaseScore uint32 `protobuf:"varint,2,opt,name=baseScore,proto3" json:"baseScore,omitempty"`
	// 庄家抢庄倍数, map 键是抢庄倍数, map 值无意义; 键意义: 0 - 不抢庄, 1 - 1倍, 2 - 2倍
	MapRobZhuangRate map[uint32]uint32 `protobuf:"bytes,3,rep,name=mapRobZhuangRate,proto3" json:"mapRobZhuangRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map 键是下注倍数, map 值无意义
	MapBetRate map[uint32]uint32 `protobuf:"bytes,4,rep,name=mapBetRate,proto3" json:"mapBetRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// map 键是牌型, map 值是牌型倍数
	MapCardTypeRate map[uint32]uint32 `protobuf:"bytes,5,rep,name=mapCardTypeRate,proto3" json:"mapCardTypeRate,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// 是否有蕃
	CardTypeHasKind bool `protobuf:"varint,6,opt,name=cardTypeHasKind,proto3" json:"cardTypeHasKind,omitempty"`
	// 各个阶段的等待时长, 这个字段是服务器使用,客户端忽略
	// 键是房间状态(niuniuRoomStatus) , 值是秒
	MapWaitTime map[uint32]int64 `protobuf:"bytes,7,rep,name=mapWaitTime,proto3" json:"mapWaitTime,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// true 明牌抢庄, false 暗牌抢庄
	KnownCard bool `protobuf:"varint,8,opt,name=knownCard,proto3" json:"knownCard,omitempty"`
	//房间玩家信息
	MapPlayerBaseInfo map[uint32]*commonProto.PlayerBaseInfo `protobuf:"bytes,9,rep,name=mapPlayerBaseInfo,proto3" json:"mapPlayerBaseInfo,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 玩家本人的基本信息
	PlayerBaseInfo *commonProto.PlayerBaseInfo `protobuf:"bytes,10,opt,name=playerBaseInfo,proto3" json:"playerBaseInfo,omitempty"`
	//局数
	NumberOfGames        uint32   `protobuf:"varint,11,opt,name=numberOfGames,proto3" json:"numberOfGames,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CSelfBuildNiuNiuRoom) Reset()         { *m = S2CSelfBuildNiuNiuRoom{} }
func (m *S2CSelfBuildNiuNiuRoom) String() string { return proto.CompactTextString(m) }
func (*S2CSelfBuildNiuNiuRoom) ProtoMessage()    {}
func (*S2CSelfBuildNiuNiuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{34}
}
func (m *S2CSelfBuildNiuNiuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CSelfBuildNiuNiuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CSelfBuildNiuNiuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CSelfBuildNiuNiuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CSelfBuildNiuNiuRoom.Merge(m, src)
}
func (m *S2CSelfBuildNiuNiuRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CSelfBuildNiuNiuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CSelfBuildNiuNiuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CSelfBuildNiuNiuRoom proto.InternalMessageInfo

func (m *S2CSelfBuildNiuNiuRoom) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CSelfBuildNiuNiuRoom) GetBaseScore() uint32 {
	if m != nil {
		return m.BaseScore
	}
	return 0
}

func (m *S2CSelfBuildNiuNiuRoom) GetMapRobZhuangRate() map[uint32]uint32 {
	if m != nil {
		return m.MapRobZhuangRate
	}
	return nil
}

func (m *S2CSelfBuildNiuNiuRoom) GetMapBetRate() map[uint32]uint32 {
	if m != nil {
		return m.MapBetRate
	}
	return nil
}

func (m *S2CSelfBuildNiuNiuRoom) GetMapCardTypeRate() map[uint32]uint32 {
	if m != nil {
		return m.MapCardTypeRate
	}
	return nil
}

func (m *S2CSelfBuildNiuNiuRoom) GetCardTypeHasKind() bool {
	if m != nil {
		return m.CardTypeHasKind
	}
	return false
}

func (m *S2CSelfBuildNiuNiuRoom) GetMapWaitTime() map[uint32]int64 {
	if m != nil {
		return m.MapWaitTime
	}
	return nil
}

func (m *S2CSelfBuildNiuNiuRoom) GetKnownCard() bool {
	if m != nil {
		return m.KnownCard
	}
	return false
}

func (m *S2CSelfBuildNiuNiuRoom) GetMapPlayerBaseInfo() map[uint32]*commonProto.PlayerBaseInfo {
	if m != nil {
		return m.MapPlayerBaseInfo
	}
	return nil
}

func (m *S2CSelfBuildNiuNiuRoom) GetPlayerBaseInfo() *commonProto.PlayerBaseInfo {
	if m != nil {
		return m.PlayerBaseInfo
	}
	return nil
}

func (m *S2CSelfBuildNiuNiuRoom) GetNumberOfGames() uint32 {
	if m != nil {
		return m.NumberOfGames
	}
	return 0
}

type Lobby2GateSelfBuildNiuNiuRoom struct {
	C2SSelfBuildNiuNiuRoom []byte   `protobuf:"bytes,1,opt,name=c2sSelfBuildNiuNiuRoom,proto3" json:"c2sSelfBuildNiuNiuRoom,omitempty"`
	NiuniuServerId         uint32   `protobuf:"varint,2,opt,name=niuniuServerId,proto3" json:"niuniuServerId,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *Lobby2GateSelfBuildNiuNiuRoom) Reset()         { *m = Lobby2GateSelfBuildNiuNiuRoom{} }
func (m *Lobby2GateSelfBuildNiuNiuRoom) String() string { return proto.CompactTextString(m) }
func (*Lobby2GateSelfBuildNiuNiuRoom) ProtoMessage()    {}
func (*Lobby2GateSelfBuildNiuNiuRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{35}
}
func (m *Lobby2GateSelfBuildNiuNiuRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Lobby2GateSelfBuildNiuNiuRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Lobby2GateSelfBuildNiuNiuRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Lobby2GateSelfBuildNiuNiuRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lobby2GateSelfBuildNiuNiuRoom.Merge(m, src)
}
func (m *Lobby2GateSelfBuildNiuNiuRoom) XXX_Size() int {
	return m.Size()
}
func (m *Lobby2GateSelfBuildNiuNiuRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_Lobby2GateSelfBuildNiuNiuRoom.DiscardUnknown(m)
}

var xxx_messageInfo_Lobby2GateSelfBuildNiuNiuRoom proto.InternalMessageInfo

func (m *Lobby2GateSelfBuildNiuNiuRoom) GetC2SSelfBuildNiuNiuRoom() []byte {
	if m != nil {
		return m.C2SSelfBuildNiuNiuRoom
	}
	return nil
}

func (m *Lobby2GateSelfBuildNiuNiuRoom) GetNiuniuServerId() uint32 {
	if m != nil {
		return m.NiuniuServerId
	}
	return 0
}

//获取自建牛牛房列表
type S2CNiuNiuGetAllSelfBuildRoom struct {
	RoomInfos            []*RoomInfo `protobuf:"bytes,1,rep,name=roomInfos,proto3" json:"roomInfos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *S2CNiuNiuGetAllSelfBuildRoom) Reset()         { *m = S2CNiuNiuGetAllSelfBuildRoom{} }
func (m *S2CNiuNiuGetAllSelfBuildRoom) String() string { return proto.CompactTextString(m) }
func (*S2CNiuNiuGetAllSelfBuildRoom) ProtoMessage()    {}
func (*S2CNiuNiuGetAllSelfBuildRoom) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{36}
}
func (m *S2CNiuNiuGetAllSelfBuildRoom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuNiuGetAllSelfBuildRoom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuNiuGetAllSelfBuildRoom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuNiuGetAllSelfBuildRoom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuNiuGetAllSelfBuildRoom.Merge(m, src)
}
func (m *S2CNiuNiuGetAllSelfBuildRoom) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuNiuGetAllSelfBuildRoom) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuNiuGetAllSelfBuildRoom.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuNiuGetAllSelfBuildRoom proto.InternalMessageInfo

func (m *S2CNiuNiuGetAllSelfBuildRoom) GetRoomInfos() []*RoomInfo {
	if m != nil {
		return m.RoomInfos
	}
	return nil
}

//当前局数通知
type S2CNiuNiuGameNumber struct {
	RoomId uint32 `protobuf:"varint,1,opt,name=roomId,proto3" json:"roomId,omitempty"`
	//当前局数
	NumberOfGame         uint32   `protobuf:"varint,2,opt,name=numberOfGame,proto3" json:"numberOfGame,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuNiuGameNumber) Reset()         { *m = S2CNiuNiuGameNumber{} }
func (m *S2CNiuNiuGameNumber) String() string { return proto.CompactTextString(m) }
func (*S2CNiuNiuGameNumber) ProtoMessage()    {}
func (*S2CNiuNiuGameNumber) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{37}
}
func (m *S2CNiuNiuGameNumber) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuNiuGameNumber) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuNiuGameNumber.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuNiuGameNumber) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuNiuGameNumber.Merge(m, src)
}
func (m *S2CNiuNiuGameNumber) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuNiuGameNumber) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuNiuGameNumber.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuNiuGameNumber proto.InternalMessageInfo

func (m *S2CNiuNiuGameNumber) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *S2CNiuNiuGameNumber) GetNumberOfGame() uint32 {
	if m != nil {
		return m.NumberOfGame
	}
	return 0
}

type S2CNiuNiuRoomWinLose struct {
	MapWinLose           map[uint32]int32 `protobuf:"bytes,1,rep,name=mapWinLose,proto3" json:"mapWinLose,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *S2CNiuNiuRoomWinLose) Reset()         { *m = S2CNiuNiuRoomWinLose{} }
func (m *S2CNiuNiuRoomWinLose) String() string { return proto.CompactTextString(m) }
func (*S2CNiuNiuRoomWinLose) ProtoMessage()    {}
func (*S2CNiuNiuRoomWinLose) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{38}
}
func (m *S2CNiuNiuRoomWinLose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuNiuRoomWinLose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuNiuRoomWinLose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuNiuRoomWinLose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuNiuRoomWinLose.Merge(m, src)
}
func (m *S2CNiuNiuRoomWinLose) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuNiuRoomWinLose) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuNiuRoomWinLose.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuNiuRoomWinLose proto.InternalMessageInfo

func (m *S2CNiuNiuRoomWinLose) GetMapWinLose() map[uint32]int32 {
	if m != nil {
		return m.MapWinLose
	}
	return nil
}

type S2CNiuniuGameStart struct {
	// 开始游戏时, 参加本局的都有哪些玩家( 的 uid 集合 )
	Uids                 []uint32 `protobuf:"varint,1,rep,packed,name=uids,proto3" json:"uids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *S2CNiuniuGameStart) Reset()         { *m = S2CNiuniuGameStart{} }
func (m *S2CNiuniuGameStart) String() string { return proto.CompactTextString(m) }
func (*S2CNiuniuGameStart) ProtoMessage()    {}
func (*S2CNiuniuGameStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_bf845778f3410074, []int{39}
}
func (m *S2CNiuniuGameStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *S2CNiuniuGameStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_S2CNiuniuGameStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *S2CNiuniuGameStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_S2CNiuniuGameStart.Merge(m, src)
}
func (m *S2CNiuniuGameStart) XXX_Size() int {
	return m.Size()
}
func (m *S2CNiuniuGameStart) XXX_DiscardUnknown() {
	xxx_messageInfo_S2CNiuniuGameStart.DiscardUnknown(m)
}

var xxx_messageInfo_S2CNiuniuGameStart proto.InternalMessageInfo

func (m *S2CNiuniuGameStart) GetUids() []uint32 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func init() {
	proto.RegisterEnum("niuniuProto.NiuniuRoomStatus", NiuniuRoomStatus_name, NiuniuRoomStatus_value)
	proto.RegisterEnum("niuniuProto.NiuniuCardType", NiuniuCardType_name, NiuniuCardType_value)
	proto.RegisterType((*RoomConfig)(nil), "niuniuProto.roomConfig")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.roomConfig.MapBetRateEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.roomConfig.MapCardTypeRateEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.roomConfig.MapRobZhuangRateEntry")
	proto.RegisterMapType((map[uint32]int64)(nil), "niuniuProto.roomConfig.MapWaitTimeEntry")
	proto.RegisterType((*RoomInfo)(nil), "niuniuProto.roomInfo")
	proto.RegisterType((*S2CNiuNiuGetAllRoom)(nil), "niuniuProto.s2cNiuNiuGetAllRoom")
	proto.RegisterType((*C2SCreateNiuniuRoom)(nil), "niuniuProto.c2sCreateNiuniuRoom")
	proto.RegisterType((*S2CCreateNiuniuRoom)(nil), "niuniuProto.s2cCreateNiuniuRoom")
	proto.RegisterType((*C2SNiuniuRoomConfig)(nil), "niuniuProto.c2sNiuniuRoomConfig")
	proto.RegisterType((*S2CNiuniuRoomConfig)(nil), "niuniuProto.s2cNiuniuRoomConfig")
	proto.RegisterType((*ReconnectSnap)(nil), "niuniuProto.reconnectSnap")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.reconnectSnap.MapBetEntry")
	proto.RegisterMapType((map[uint32]int32)(nil), "niuniuProto.reconnectSnap.MapPlayerGoldEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.reconnectSnap.MapRobZhuangEntry")
	proto.RegisterMapType((map[uint32]*S2CNiuniuShowCard)(nil), "niuniuProto.reconnectSnap.MapShowCardEntry")
	proto.RegisterMapType((map[uint32]int32)(nil), "niuniuProto.reconnectSnap.MapWinOrLoseEntry")
	proto.RegisterType((*C2SEnterNiuniuRoom)(nil), "niuniuProto.c2sEnterNiuniuRoom")
	proto.RegisterType((*Lobby2GateEnterNiuniuRoom)(nil), "niuniuProto.lobby2GateEnterNiuniuRoom")
	proto.RegisterType((*S2CEnterNiuniuRoom)(nil), "niuniuProto.s2cEnterNiuniuRoom")
	proto.RegisterMapType((map[uint32]*commonProto.PlayerBaseInfo)(nil), "niuniuProto.s2cEnterNiuniuRoom.MapPlayerBaseInfoEntry")
	proto.RegisterType((*S2COtherPlayerEnterNiuniuRoom)(nil), "niuniuProto.s2cOtherPlayerEnterNiuniuRoom")
	proto.RegisterType((*C2SLeaveNiuniuRoom)(nil), "niuniuProto.c2sLeaveNiuniuRoom")
	proto.RegisterType((*S2CLeaveNiuniuRoom)(nil), "niuniuProto.s2cLeaveNiuniuRoom")
	proto.RegisterType((*S2CBroadcastLeaveNiuniuRoom)(nil), "niuniuProto.s2cBroadcastLeaveNiuniuRoom")
	proto.RegisterType((*S2CNiuniuClientDisconnect)(nil), "niuniuProto.s2cNiuniuClientDisconnect")
	proto.RegisterType((*S2CNiuniuBroadcastRoomStatus)(nil), "niuniuProto.s2cNiuniuBroadcastRoomStatus")
	proto.RegisterType((*C2SNiuniuReady)(nil), "niuniuProto.c2sNiuniuReady")
	proto.RegisterType((*S2CNiuniuReady)(nil), "niuniuProto.s2cNiuniuReady")
	proto.RegisterType((*S2CNiuniuSendKnownCard)(nil), "niuniuProto.s2cNiuniuSendKnownCard")
	proto.RegisterType((*C2SNiuniuRobZhuang)(nil), "niuniuProto.c2sNiuniuRobZhuang")
	proto.RegisterType((*S2CNiuniuRobZhuang)(nil), "niuniuProto.s2cNiuniuRobZhuang")
	proto.RegisterType((*S2CConfirmBanker)(nil), "niuniuProto.s2cConfirmBanker")
	proto.RegisterType((*C2SNiuniuBet)(nil), "niuniuProto.c2sNiuniuBet")
	proto.RegisterType((*S2CNiuniuBet)(nil), "niuniuProto.s2cNiuniuBet")
	proto.RegisterType((*S2CNiuniuSendOneUnknownCard)(nil), "niuniuProto.s2cNiuniuSendOneUnknownCard")
	proto.RegisterType((*C2SNiuniuShowCard)(nil), "niuniuProto.c2sNiuniuShowCard")
	proto.RegisterType((*S2CNiuniuShowCard)(nil), "niuniuProto.s2cNiuniuShowCard")
	proto.RegisterType((*S2CNiuniuSettle)(nil), "niuniuProto.s2cNiuniuSettle")
	proto.RegisterMapType((map[uint32]int32)(nil), "niuniuProto.s2cNiuniuSettle.MapPlayerGoldEntry")
	proto.RegisterMapType((map[uint32]int32)(nil), "niuniuProto.s2cNiuniuSettle.MapWinOrLoseEntry")
	proto.RegisterMapType((map[uint32]int32)(nil), "niuniuProto.s2cNiuniuSettle.MapWinOrLoseFinalEntry")
	proto.RegisterType((*S2CNiuniuHaveASeat)(nil), "niuniuProto.s2cNiuniuHaveASeat")
	proto.RegisterType((*S2CNiuniuLeaveTheSeat)(nil), "niuniuProto.s2cNiuniuLeaveTheSeat")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.s2cNiuniuLeaveTheSeat.MapUidSeatEntry")
	proto.RegisterType((*C2SNiuniuPing)(nil), "niuniuProto.c2sNiuniuPing")
	proto.RegisterType((*S2CNiuniuPong)(nil), "niuniuProto.s2cNiuniuPong")
	proto.RegisterType((*C2SSelfBuildNiuNiuRoom)(nil), "niuniuProto.c2sSelfBuildNiuNiuRoom")
	proto.RegisterType((*S2CSelfBuildNiuNiuRoom)(nil), "niuniuProto.s2cSelfBuildNiuNiuRoom")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.s2cSelfBuildNiuNiuRoom.MapBetRateEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.s2cSelfBuildNiuNiuRoom.MapCardTypeRateEntry")
	proto.RegisterMapType((map[uint32]*commonProto.PlayerBaseInfo)(nil), "niuniuProto.s2cSelfBuildNiuNiuRoom.MapPlayerBaseInfoEntry")
	proto.RegisterMapType((map[uint32]uint32)(nil), "niuniuProto.s2cSelfBuildNiuNiuRoom.MapRobZhuangRateEntry")
	proto.RegisterMapType((map[uint32]int64)(nil), "niuniuProto.s2cSelfBuildNiuNiuRoom.MapWaitTimeEntry")
	proto.RegisterType((*Lobby2GateSelfBuildNiuNiuRoom)(nil), "niuniuProto.lobby2GateSelfBuildNiuNiuRoom")
	proto.RegisterType((*S2CNiuNiuGetAllSelfBuildRoom)(nil), "niuniuProto.s2cNiuNiuGetAllSelfBuildRoom")
	proto.RegisterType((*S2CNiuNiuGameNumber)(nil), "niuniuProto.s2cNiuNiuGameNumber")
	proto.RegisterType((*S2CNiuNiuRoomWinLose)(nil), "niuniuProto.s2cNiuNiuRoomWinLose")
	proto.RegisterMapType((map[uint32]int32)(nil), "niuniuProto.s2cNiuNiuRoomWinLose.MapWinLoseEntry")
	proto.RegisterType((*S2CNiuniuGameStart)(nil), "niuniuProto.s2cNiuniuGameStart")
}

func init() { proto.RegisterFile("niuniu_struct.proto", fileDescriptor_bf845778f3410074) }

var fileDescriptor_bf845778f3410074 = []byte{
	// 2335 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0x4b, 0x6f, 0x1b, 0xc9,
	0x11, 0xf6, 0x90, 0x22, 0x25, 0x95, 0x44, 0x69, 0xd4, 0x7a, 0x78, 0xac, 0xb5, 0x05, 0x61, 0xb0,
	0x70, 0x04, 0xaf, 0x57, 0xbb, 0xa6, 0x1c, 0xc7, 0x36, 0xb0, 0x9b, 0x2c, 0xe5, 0x95, 0xec, 0xb5,
	0x2d, 0xc9, 0x43, 0x7b, 0x8d, 0x24, 0x40, 0x16, 0xcd, 0x99, 0x96, 0x38, 0xd0, 0x3c, 0x98, 0x99,
	0x1e, 0xc9, 0x42, 0x0e, 0xf9, 0x1b, 0x41, 0xae, 0x41, 0x80, 0xfc, 0x92, 0x24, 0xa7, 0x45, 0xce,
	0x39, 0x05, 0xce, 0x25, 0xa7, 0x1c, 0xf2, 0x0b, 0x82, 0xae, 0x9e, 0x37, 0x87, 0x14, 0x65, 0x04,
	0x41, 0x0e, 0xb9, 0x4d, 0x7f, 0x5d, 0x55, 0x5d, 0xdd, 0x5d, 0xaf, 0x2e, 0x12, 0x96, 0x3d, 0x3b,
	0xf2, 0xec, 0xe8, 0xbb, 0x90, 0x07, 0x91, 0xc9, 0xb7, 0x07, 0x81, 0xcf, 0x7d, 0x32, 0x27, 0xc1,
	0x23, 0x31, 0x58, 0x5f, 0x36, 0x7d, 0xd7, 0xf5, 0xbd, 0x02, 0x85, 0xfe, 0xcf, 0x26, 0x40, 0xe0,
	0xfb, 0xee, 0xae, 0xef, 0x1d, 0xdb, 0x27, 0x64, 0x0d, 0x9a, 0x62, 0xf4, 0xcc, 0xd2, 0x94, 0x4d,
	0x65, 0xab, 0x65, 0xc4, 0x23, 0x72, 0x13, 0x66, 0x7b, 0x34, 0x64, 0x5d, 0xd3, 0x0f, 0x98, 0x56,
	0xc3, 0xa9, 0x0c, 0x20, 0x3f, 0x05, 0xd5, 0xa5, 0x03, 0xc3, 0xef, 0xfd, 0xac, 0x1f, 0x51, 0xef,
	0xc4, 0xa0, 0x9c, 0x69, 0xf5, 0xcd, 0xfa, 0xd6, 0x5c, 0xfb, 0xd3, 0xed, 0x9c, 0x06, 0xdb, 0xd9,
	0x42, 0xdb, 0x2f, 0x4b, 0xf4, 0x5f, 0x7b, 0x3c, 0xb8, 0x30, 0x86, 0xc4, 0x90, 0x7d, 0x00, 0x97,
	0x0e, 0x3a, 0x8c, 0xa3, 0xd0, 0x29, 0x14, 0xfa, 0x83, 0x31, 0x42, 0x63, 0x4a, 0x29, 0x2e, 0xc7,
	0x4a, 0xbe, 0x85, 0x45, 0x97, 0x0e, 0x76, 0x69, 0x60, 0xbd, 0xbe, 0x18, 0x30, 0x94, 0xd6, 0x40,
	0x69, 0x77, 0xc7, 0x48, 0xcb, 0x93, 0x4b, 0x91, 0x65, 0x21, 0x64, 0x0b, 0x16, 0xcd, 0x78, 0xfc,
	0x94, 0x86, 0xcf, 0x6d, 0xcf, 0xd2, 0x9a, 0x9b, 0xca, 0xd6, 0x8c, 0x51, 0x86, 0xc9, 0x37, 0x30,
	0xe7, 0xd2, 0xc1, 0x5b, 0x6a, 0xf3, 0xd7, 0xb6, 0xcb, 0xb4, 0x69, 0x5c, 0x7d, 0x6b, 0xcc, 0xea,
	0x09, 0xa9, 0x5c, 0x39, 0xcf, 0x2c, 0xee, 0xe3, 0xd4, 0xf3, 0xcf, 0x3d, 0xa1, 0x8a, 0x36, 0x83,
	0xeb, 0x65, 0x00, 0xb9, 0x0b, 0x4b, 0xdc, 0xe7, 0xd4, 0x39, 0x88, 0xdc, 0x1e, 0x0b, 0x0e, 0x8f,
	0xf7, 0xa9, 0xcb, 0xb4, 0x59, 0xbc, 0xb5, 0xe1, 0x09, 0x72, 0x1b, 0x16, 0x90, 0x35, 0x3d, 0x78,
	0x0d, 0x50, 0x60, 0x09, 0x25, 0x2a, 0xd4, 0x4f, 0xa9, 0xa7, 0xcd, 0xe1, 0xa4, 0xf8, 0x24, 0x04,
	0xa6, 0xc2, 0x7e, 0xe4, 0x69, 0xf3, 0x08, 0xe1, 0xb7, 0xb0, 0xa0, 0x63, 0x1a, 0x72, 0x16, 0x68,
	0x2d, 0x44, 0xe3, 0xd1, 0xfa, 0x2e, 0xac, 0x56, 0xde, 0x39, 0x8a, 0x65, 0x17, 0xb1, 0xbd, 0x89,
	0x4f, 0xb2, 0x02, 0x8d, 0x33, 0xea, 0x44, 0x89, 0xa1, 0xc9, 0xc1, 0xe3, 0xda, 0x43, 0x65, 0xfd,
	0x0b, 0x58, 0x2c, 0xdd, 0xf1, 0x95, 0xd8, 0x3b, 0xb0, 0x52, 0x75, 0xa9, 0x57, 0x92, 0xf1, 0x25,
	0xa8, 0xe5, 0xab, 0xb9, 0x8c, 0xbf, 0x9e, 0xe3, 0xd7, 0x43, 0x98, 0x41, 0x9f, 0xf2, 0x8e, 0x7d,
	0x71, 0x8b, 0x03, 0x87, 0x5e, 0xb0, 0xe0, 0x20, 0x72, 0x63, 0xee, 0x0c, 0xc8, 0xf9, 0x62, 0xad,
	0xe0, 0x8b, 0xf7, 0xa4, 0x04, 0xb1, 0x05, 0xad, 0xbe, 0xa9, 0x6c, 0x2d, 0xb4, 0x57, 0xb7, 0xa5,
	0x6b, 0x67, 0x46, 0x84, 0xfb, 0x4b, 0xc9, 0xf4, 0x6f, 0x60, 0x39, 0x6c, 0x9b, 0x07, 0x76, 0x74,
	0x60, 0x47, 0xfb, 0x8c, 0x7f, 0xe5, 0x38, 0x86, 0xef, 0xbb, 0x64, 0x07, 0x66, 0x13, 0x5d, 0x42,
	0x4d, 0x41, 0x7b, 0x5c, 0x1d, 0xb2, 0x47, 0x31, 0x6b, 0x64, 0x74, 0xfa, 0x0e, 0x2c, 0x9b, 0xed,
	0x70, 0x37, 0x60, 0x94, 0xb3, 0x03, 0xa4, 0x45, 0x59, 0x63, 0xf7, 0xa2, 0xaf, 0xa2, 0x02, 0x65,
	0xa6, 0x58, 0x56, 0x06, 0xc4, 0x51, 0xe8, 0x26, 0x4c, 0xcb, 0xbd, 0x4a, 0xad, 0x5a, 0x9d, 0x9a,
	0xaa, 0x18, 0x09, 0xa4, 0x77, 0x92, 0xcd, 0x14, 0x99, 0x3e, 0x81, 0x29, 0xf3, 0xf8, 0x24, 0xd9,
	0xc7, 0xf5, 0x11, 0x7e, 0x65, 0x20, 0x91, 0xfe, 0xc7, 0x69, 0x68, 0x05, 0xcc, 0xf4, 0x3d, 0x8f,
	0x99, 0xbc, 0xeb, 0xd1, 0x81, 0x58, 0x73, 0x10, 0xb0, 0xc1, 0x80, 0x05, 0xf9, 0x35, 0x63, 0x88,
	0x1c, 0xc1, 0x7c, 0x3e, 0x34, 0x69, 0xb5, 0xaa, 0xd0, 0x91, 0x97, 0x57, 0x08, 0x70, 0xd2, 0x81,
	0x0b, 0x12, 0xc8, 0x03, 0x80, 0xd4, 0x61, 0xc3, 0x38, 0x5a, 0xae, 0x15, 0xee, 0x71, 0xe0, 0x9f,
	0xb2, 0x40, 0x4c, 0x1b, 0x39, 0x4a, 0xa2, 0x03, 0xc8, 0x63, 0x7d, 0x63, 0x5b, 0x21, 0x06, 0x44,
	0xa9, 0x6a, 0x0e, 0x25, 0x5f, 0x42, 0x53, 0x46, 0xbe, 0x38, 0xc4, 0xdd, 0x1e, 0xaf, 0x67, 0x87,
	0x71, 0xa9, 0x61, 0xcc, 0x45, 0xd6, 0x61, 0xa6, 0x47, 0xbd, 0x53, 0x16, 0x3c, 0x93, 0xc1, 0xac,
	0x65, 0xa4, 0x63, 0xf2, 0x12, 0xa3, 0x58, 0xb7, 0xef, 0x9f, 0x63, 0xec, 0x91, 0x51, 0xec, 0x93,
	0xf1, 0x0b, 0x24, 0xd4, 0x59, 0x20, 0x4b, 0x90, 0xf8, 0x60, 0xdf, 0xda, 0xde, 0x61, 0xf0, 0xc2,
	0x0f, 0x99, 0x36, 0x33, 0xc9, 0xc1, 0xa6, 0xe4, 0xd9, 0xc1, 0xa6, 0x10, 0x79, 0x08, 0x73, 0x91,
	0x97, 0x05, 0x47, 0x11, 0xf6, 0x46, 0x9f, 0x6c, 0x9e, 0x94, 0x74, 0xa1, 0xe5, 0xd2, 0xc1, 0x11,
	0x9e, 0xe3, 0xbe, 0xef, 0x58, 0x1a, 0x54, 0xe5, 0xb0, 0xb2, 0x32, 0x19, 0xbd, 0xd4, 0xa6, 0x28,
	0x63, 0xfd, 0xc7, 0xb0, 0x34, 0x64, 0x0a, 0x57, 0x0a, 0x38, 0x8f, 0x60, 0x2e, 0x77, 0x47, 0x57,
	0x62, 0xfd, 0x05, 0xc6, 0xaa, 0xc2, 0xe9, 0x57, 0xf0, 0xdf, 0xcf, 0xf3, 0xcf, 0xb5, 0x37, 0x0a,
	0xdb, 0x4d, 0x3d, 0x2d, 0x91, 0x92, 0x97, 0x2f, 0xf7, 0x56, 0xbc, 0x8d, 0xcb, 0x14, 0x6c, 0xe4,
	0x05, 0xfc, 0x04, 0xc8, 0xf0, 0x09, 0x5e, 0x45, 0x82, 0x6e, 0x00, 0x31, 0xdb, 0xe1, 0xd7, 0x1e,
	0x67, 0x41, 0x2e, 0x18, 0x8d, 0x2a, 0x63, 0x54, 0xa8, 0x47, 0x76, 0x12, 0x4f, 0xc5, 0xa7, 0x48,
	0x61, 0xe7, 0xef, 0x6c, 0x0b, 0x03, 0xe9, 0xac, 0x81, 0xdf, 0x7a, 0x08, 0x37, 0x1c, 0xbf, 0xd7,
	0xbb, 0x68, 0xef, 0xcb, 0x0c, 0x51, 0x10, 0xbd, 0x5d, 0xb5, 0x20, 0x2e, 0x33, 0x6f, 0x54, 0xa9,
	0x72, 0x1b, 0x16, 0xe4, 0x79, 0x76, 0x59, 0x70, 0x86, 0x1e, 0x25, 0x57, 0x2f, 0xa1, 0xfa, 0x5f,
	0xa7, 0x80, 0x84, 0x6d, 0x73, 0xd2, 0x9d, 0x58, 0xb0, 0x94, 0xda, 0x59, 0x87, 0x86, 0x4c, 0xc4,
	0xe6, 0x38, 0x2a, 0x3d, 0x28, 0x5f, 0x60, 0x49, 0x66, 0x66, 0xb4, 0x09, 0xa3, 0x34, 0xdc, 0x61,
	0x81, 0x64, 0x17, 0x16, 0x06, 0xc5, 0x25, 0xea, 0x68, 0x23, 0x1f, 0x15, 0xdd, 0xa9, 0x40, 0x62,
	0x94, 0x58, 0xc8, 0x17, 0xb2, 0xc2, 0xec, 0x72, 0xca, 0x23, 0x11, 0xb1, 0x44, 0xc6, 0xba, 0x55,
	0xd0, 0xd1, 0x4b, 0x75, 0x93, 0x44, 0x46, 0x8e, 0x81, 0xe8, 0x30, 0xdf, 0xbb, 0x08, 0x39, 0xf5,
	0x2c, 0x99, 0x5b, 0x1a, 0x78, 0x0e, 0x05, 0x4c, 0x24, 0x1f, 0xd3, 0x8f, 0x3c, 0xfe, 0xc4, 0x3f,
	0xf7, 0xe2, 0x88, 0x95, 0x01, 0xa4, 0x0d, 0xcd, 0xc0, 0x14, 0xee, 0xaa, 0x4d, 0xa3, 0xf6, 0xeb,
	0xa3, 0x1d, 0xda, 0x88, 0x29, 0xc9, 0x67, 0xd0, 0x34, 0x31, 0x61, 0x60, 0x75, 0x35, 0x26, 0x9f,
	0xc4, 0x64, 0x42, 0x4d, 0x6f, 0xb8, 0xdc, 0x2a, 0x60, 0xc2, 0x8c, 0xfd, 0x73, 0x8f, 0x05, 0x58,
	0x60, 0xb5, 0x0c, 0x39, 0x58, 0xa7, 0xb0, 0x56, 0x7d, 0x23, 0x15, 0x8e, 0x70, 0xaf, 0xe8, 0xab,
	0x63, 0xef, 0x21, 0xe7, 0x25, 0x3f, 0x87, 0x5b, 0x61, 0xdb, 0x3c, 0xe4, 0x7d, 0x16, 0xc8, 0x75,
	0x26, 0x35, 0xb3, 0xf2, 0xe1, 0xd7, 0x86, 0x0f, 0x5f, 0x5f, 0x41, 0x8f, 0x78, 0xc1, 0xe8, 0x59,
	0x3e, 0xb5, 0xdf, 0x45, 0x73, 0x2e, 0xa1, 0xa3, 0xd6, 0xd1, 0xcf, 0xe1, 0xa3, 0xb0, 0x6d, 0x76,
	0x02, 0x9f, 0x5a, 0x26, 0x0d, 0xf9, 0x84, 0x6c, 0x93, 0xa8, 0x27, 0x6c, 0x23, 0x64, 0x94, 0x3f,
	0xf3, 0x2c, 0xf6, 0x0e, 0xcd, 0xb7, 0x61, 0x64, 0x80, 0xfe, 0x0a, 0x6e, 0xa4, 0x21, 0x6e, 0xd7,
	0xb1, 0x99, 0xc7, 0x9f, 0xd8, 0x61, 0x6c, 0x10, 0xe3, 0x5e, 0x43, 0x99, 0xc8, 0x5a, 0x59, 0xe4,
	0xaf, 0xe0, 0x66, 0x2a, 0x32, 0xdd, 0x51, 0x66, 0xdc, 0x25, 0x7f, 0x50, 0xae, 0xea, 0x0f, 0x05,
	0x5b, 0xaf, 0x95, 0x6c, 0x5d, 0x57, 0x61, 0x21, 0xab, 0xa8, 0x18, 0xb5, 0x2e, 0xf4, 0x3d, 0x58,
	0xc8, 0xca, 0x25, 0x81, 0x24, 0x51, 0x50, 0xc9, 0xa2, 0xe0, 0x24, 0xd7, 0xbc, 0x07, 0x6b, 0x59,
	0x32, 0x60, 0x9e, 0xf5, 0x3c, 0xf7, 0xdc, 0x68, 0x98, 0x58, 0xc5, 0x28, 0x63, 0xab, 0x18, 0x49,
	0xa4, 0x6f, 0xa1, 0xb9, 0x24, 0x97, 0x9b, 0x94, 0x43, 0x04, 0xa6, 0x02, 0xf1, 0x26, 0x93, 0x4a,
	0xe1, 0xb7, 0xfe, 0x18, 0x4d, 0x68, 0x02, 0xca, 0xe1, 0xb8, 0xae, 0x1f, 0x81, 0x2a, 0x0a, 0x4e,
	0xe1, 0x9b, 0x81, 0xdb, 0xc1, 0xe2, 0xa5, 0x62, 0xdf, 0x89, 0xac, 0x5a, 0x4e, 0xd6, 0x1a, 0x4c,
	0x45, 0x76, 0x5c, 0x92, 0xc9, 0xd2, 0x0a, 0xc7, 0xfa, 0x26, 0xcc, 0xa7, 0x7a, 0x8b, 0x22, 0x49,
	0x85, 0x7a, 0x8f, 0xf1, 0x44, 0x5a, 0x8f, 0x71, 0xbd, 0x0d, 0xf3, 0xd9, 0xc5, 0x57, 0x51, 0x54,
	0xe8, 0xf9, 0x0c, 0x0d, 0x3f, 0x3b, 0xd5, 0x43, 0x8f, 0xbd, 0xc9, 0x95, 0x24, 0x77, 0x60, 0x4a,
	0x9c, 0x1a, 0xca, 0x18, 0x7d, 0xb2, 0x48, 0xa3, 0x2f, 0xc3, 0x52, 0xaa, 0x60, 0x92, 0xad, 0xf5,
	0xdf, 0x29, 0xb0, 0x34, 0x94, 0xc3, 0x2b, 0x4e, 0x22, 0xbd, 0xc3, 0xda, 0x04, 0x77, 0x28, 0x0a,
	0xc4, 0xe4, 0x75, 0x8b, 0x2e, 0xd5, 0x32, 0xd2, 0x31, 0x69, 0xcb, 0xb9, 0x5d, 0xdf, 0xed, 0xc5,
	0xef, 0xf5, 0x51, 0xc2, 0x52, 0x3a, 0xfd, 0x1f, 0x75, 0x58, 0xcc, 0x1d, 0x03, 0xe7, 0x0e, 0x23,
	0x46, 0xa9, 0x32, 0x94, 0xc6, 0xb5, 0x3d, 0xa2, 0x3a, 0x41, 0x9e, 0x4b, 0x6b, 0xc3, 0x37, 0xe5,
	0x0a, 0x4f, 0xee, 0xf6, 0xb3, 0xcb, 0x84, 0x8e, 0xaf, 0xf1, 0x08, 0xc5, 0x64, 0x9c, 0x2e, 0xb3,
	0x67, 0x7b, 0xd4, 0x89, 0x4b, 0xfa, 0x9d, 0x89, 0xf5, 0x45, 0xae, 0x2c, 0x13, 0x17, 0xf1, 0xff,
	0x81, 0x52, 0x6b, 0xfd, 0x09, 0xe6, 0xa9, 0x0a, 0x7d, 0xaf, 0x54, 0xb0, 0xfd, 0x5e, 0xc9, 0x79,
	0xf5, 0x53, 0x7a, 0xc6, 0xbe, 0xea, 0x32, 0xca, 0x89, 0x06, 0xd3, 0x18, 0x41, 0xad, 0x77, 0xb1,
	0x98, 0x64, 0x28, 0xe2, 0x9d, 0x1d, 0x76, 0xed, 0x2c, 0xde, 0xcd, 0x18, 0x19, 0x30, 0x14, 0xb9,
	0xea, 0x15, 0x19, 0x60, 0x07, 0x9a, 0x32, 0x35, 0x62, 0xf1, 0x71, 0x49, 0xd6, 0x8c, 0x49, 0xf5,
	0xef, 0x15, 0x58, 0x4d, 0xf5, 0xc4, 0x7c, 0xf4, 0xba, 0xcf, 0x50, 0x55, 0x03, 0x5b, 0x52, 0x6f,
	0x6c, 0x4b, 0x8c, 0x62, 0xb3, 0x6c, 0x57, 0x5f, 0x73, 0x9e, 0x4f, 0x5c, 0x76, 0xcc, 0x94, 0x75,
	0xa7, 0x62, 0x60, 0x92, 0x00, 0x1c, 0x37, 0x3f, 0xf2, 0x22, 0xae, 0xf2, 0x18, 0xd0, 0x3f, 0x85,
	0x56, 0x1a, 0x1e, 0x8e, 0x6c, 0x4f, 0xbc, 0xb2, 0x67, 0xb9, 0xed, 0xb2, 0x90, 0x53, 0x77, 0x80,
	0x22, 0xea, 0x46, 0x06, 0x08, 0xf2, 0x74, 0x1b, 0x47, 0xfe, 0xa5, 0xe4, 0xbf, 0x6d, 0xc2, 0x9a,
	0xd9, 0x0e, 0xbb, 0xcc, 0x39, 0xee, 0x44, 0xb6, 0x63, 0xc9, 0x5e, 0x03, 0x26, 0xef, 0x8f, 0xa1,
	0x25, 0xce, 0xd4, 0xf6, 0x4e, 0x5e, 0x32, 0xde, 0xf7, 0x65, 0xd8, 0x69, 0x18, 0x45, 0x50, 0x9c,
	0x80, 0xe3, 0x9f, 0xef, 0x07, 0xd4, 0x62, 0x18, 0x56, 0xa4, 0xe1, 0x14, 0x30, 0x11, 0x76, 0x92,
	0x71, 0x9c, 0xc9, 0xd3, 0xf1, 0x50, 0xfd, 0x35, 0x25, 0xf9, 0x0b, 0xf5, 0xd7, 0x26, 0xcc, 0x59,
	0x7e, 0xd4, 0x73, 0x98, 0x11, 0x39, 0x2c, 0xc4, 0x4a, 0xb2, 0x61, 0xe4, 0x21, 0x51, 0xdd, 0x87,
	0x03, 0x66, 0xda, 0xd4, 0x79, 0x92, 0x23, 0x6c, 0x22, 0x61, 0xc5, 0x0c, 0xf9, 0x1c, 0x96, 0x79,
	0x9f, 0x75, 0xec, 0x93, 0x13, 0x26, 0x72, 0x7c, 0xd2, 0x1e, 0x98, 0x46, 0x86, 0xaa, 0x29, 0x72,
	0x07, 0x54, 0xe9, 0x84, 0x47, 0x51, 0xd8, 0x97, 0x7d, 0x38, 0x2c, 0x31, 0x1b, 0xc6, 0x10, 0x2e,
	0xf6, 0x94, 0xb6, 0x50, 0x04, 0x5d, 0x5c, 0x53, 0xe6, 0x31, 0x61, 0x02, 0xd4, 0xb2, 0xb0, 0xa2,
	0x6c, 0x18, 0xe2, 0x53, 0x9c, 0x12, 0xef, 0xb3, 0x6e, 0xdf, 0xf7, 0x39, 0x36, 0xeb, 0x1a, 0x46,
	0x3a, 0x16, 0xab, 0xcb, 0xed, 0x76, 0x7c, 0xce, 0x7d, 0xf7, 0xc8, 0x8f, 0x02, 0xec, 0xde, 0x35,
	0x8c, 0x21, 0x1c, 0xbb, 0x00, 0xd1, 0xc5, 0x53, 0x3f, 0x08, 0x19, 0xf6, 0xf2, 0x1a, 0x46, 0x3a,
	0xc6, 0x39, 0xc6, 0x5f, 0xd8, 0xae, 0xcd, 0xb5, 0x85, 0x78, 0x2e, 0x1e, 0x8b, 0x17, 0x8f, 0x45,
	0x83, 0xd3, 0xfd, 0x80, 0xf6, 0x64, 0xe2, 0xd5, 0x16, 0x91, 0xa2, 0x84, 0x0a, 0x83, 0x3a, 0xa6,
	0x26, 0x93, 0x0d, 0x10, 0x55, 0x56, 0x51, 0x29, 0x20, 0xac, 0xe6, 0xd4, 0xf6, 0x4e, 0x5e, 0x50,
	0xfb, 0xb9, 0xed, 0x9d, 0x1c, 0x1e, 0x6b, 0x4b, 0xd2, 0x6a, 0x0a, 0xa0, 0xd0, 0xa3, 0xcf, 0xf6,
	0xec, 0x93, 0x3e, 0x0f, 0x35, 0x22, 0xf5, 0x48, 0xc6, 0x42, 0x0f, 0xea, 0xf8, 0xde, 0xc9, 0xeb,
	0x3e, 0xeb, 0x44, 0xe6, 0x29, 0xe3, 0xda, 0xb2, 0xd4, 0xa3, 0x88, 0x92, 0x0d, 0x59, 0x8f, 0x1d,
	0x45, 0x3d, 0xc7, 0x36, 0xb5, 0x15, 0xa4, 0xc9, 0x21, 0x62, 0x0d, 0x31, 0xc2, 0x96, 0xf1, 0xaa,
	0x5c, 0x23, 0x19, 0x27, 0x89, 0x74, 0x6d, 0xf8, 0x41, 0x79, 0x3d, 0xf7, 0xa0, 0xfc, 0x7e, 0x06,
	0x6b, 0xa7, 0x2a, 0xe7, 0xf8, 0xb0, 0x86, 0x3b, 0x1b, 0xd9, 0x70, 0x7f, 0x54, 0x0e, 0x44, 0x15,
	0x8b, 0x4e, 0xdc, 0x7c, 0xef, 0x56, 0x34, 0xdf, 0x77, 0x26, 0x5c, 0x60, 0x64, 0x23, 0xbe, 0x37,
	0xaa, 0x11, 0xff, 0x70, 0x42, 0xc9, 0xff, 0xd1, 0xa6, 0xfc, 0xb7, 0x55, 0x4d, 0xf9, 0xfb, 0x13,
	0x6a, 0xf2, 0xc1, 0x0d, 0xfa, 0x7e, 0xd5, 0xeb, 0x7d, 0x16, 0xd7, 0x7e, 0x3c, 0xe1, 0xda, 0x1f,
	0xfc, 0x82, 0x87, 0xab, 0xbf, 0xe0, 0x3f, 0x86, 0x56, 0x3e, 0x8e, 0x86, 0x18, 0x56, 0x5a, 0x46,
	0x11, 0xfc, 0x7f, 0x87, 0x3f, 0xe6, 0xff, 0x2f, 0xbc, 0xe7, 0x7f, 0x0d, 0xb7, 0xb2, 0x0e, 0x55,
	0x55, 0x58, 0x79, 0x30, 0x2a, 0x1b, 0xc7, 0x9d, 0xaa, 0x51, 0xb9, 0x7a, 0xd2, 0x6e, 0x55, 0x37,
	0x79, 0xe3, 0xa6, 0x3f, 0x28, 0xa4, 0xd2, 0x3e, 0xfc, 0x97, 0x85, 0x57, 0xf9, 0x5f, 0x29, 0xa8,
	0xcb, 0xe2, 0x0c, 0x37, 0xe6, 0xf1, 0x5f, 0xc8, 0xf8, 0xb5, 0xe1, 0x8e, 0x8b, 0xfe, 0x07, 0x05,
	0x56, 0x52, 0x99, 0x42, 0xb3, 0xb7, 0xb6, 0x87, 0x2f, 0x81, 0x57, 0x18, 0xda, 0xe2, 0x51, 0xac,
	0xe1, 0xbd, 0x8a, 0x22, 0xae, 0xc8, 0x16, 0x17, 0xec, 0xd9, 0xf3, 0x22, 0x27, 0x24, 0x36, 0xdd,
	0xfc, 0xf4, 0x95, 0x0a, 0xe3, 0xbb, 0xb9, 0xba, 0x58, 0xe8, 0xde, 0xe5, 0x34, 0xe0, 0xe9, 0x6b,
	0x54, 0x29, 0xbe, 0x46, 0xef, 0xfc, 0x4b, 0x01, 0xb5, 0xdc, 0x26, 0x20, 0x1a, 0xac, 0x94, 0xb1,
	0x03, 0xdf, 0x63, 0xea, 0x35, 0x72, 0x03, 0x56, 0x87, 0x9a, 0x0a, 0x8c, 0x5a, 0x17, 0xaa, 0x42,
	0x6e, 0xc1, 0x8d, 0xf2, 0xd4, 0x6e, 0xd2, 0x4e, 0x50, 0x9b, 0x55, 0xd3, 0xa9, 0x8b, 0xab, 0x35,
	0x72, 0x3d, 0xf9, 0xe1, 0x39, 0x9b, 0xee, 0x30, 0xae, 0xd6, 0xab, 0x74, 0x11, 0x2e, 0xa1, 0x4e,
	0x91, 0x75, 0x58, 0x2b, 0xcf, 0xc8, 0xe7, 0x90, 0xda, 0x20, 0x37, 0x41, 0x2b, 0xcf, 0x89, 0xb3,
	0x38, 0x3c, 0x63, 0x81, 0x3a, 0x7d, 0xe7, 0x4f, 0xf5, 0xc4, 0x3c, 0x13, 0x0f, 0x27, 0x2b, 0xc9,
	0x31, 0x24, 0xc8, 0x77, 0x9f, 0xab, 0xd7, 0x2a, 0xd0, 0x7b, 0xaa, 0x52, 0x81, 0xb6, 0xd5, 0x5a,
	0x05, 0xba, 0xa3, 0xd6, 0x2b, 0xd0, 0xfb, 0xea, 0x54, 0x05, 0xfa, 0x43, 0xb5, 0x51, 0x81, 0x3e,
	0x50, 0x9b, 0x15, 0xe8, 0x8f, 0xd4, 0xe9, 0x0a, 0xf4, 0xa1, 0x3a, 0x53, 0x81, 0x3e, 0x52, 0x67,
	0xc9, 0x1a, 0x90, 0x12, 0xea, 0xd9, 0x91, 0x0a, 0x15, 0x78, 0xc8, 0x7e, 0xa9, 0xce, 0x65, 0x57,
	0x95, 0xe2, 0xc7, 0xf6, 0x19, 0xdb, 0x73, 0xfc, 0x73, 0x16, 0xa8, 0xf3, 0x15, 0xd3, 0x21, 0x75,
	0x93, 0xe9, 0x56, 0x76, 0x93, 0xe9, 0x74, 0x3f, 0x72, 0x22, 0x75, 0xa1, 0x62, 0xa2, 0xe7, 0xfb,
	0xae, 0xba, 0x58, 0x31, 0x21, 0xd6, 0x53, 0x55, 0xb2, 0x09, 0x37, 0xcb, 0x2b, 0xf1, 0x80, 0x8a,
	0xaa, 0x6c, 0xcf, 0x89, 0xc2, 0xbe, 0xba, 0xd4, 0x51, 0xff, 0xfc, 0x7e, 0x43, 0xf9, 0xcb, 0xfb,
	0x0d, 0xe5, 0x6f, 0xef, 0x37, 0x94, 0xdf, 0xfc, 0x7d, 0xe3, 0x5a, 0xaf, 0x89, 0xff, 0x47, 0xd8,
	0xf9, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa4, 0x93, 0x4a, 0xcf, 0xc8, 0x20, 0x00, 0x00,
}

func (m *RoomConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Faster {
		i--
		if m.Faster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Shun {
		i--
		if m.Shun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.Kan {
		i--
		if m.Kan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.KnownRobZhuang {
		i--
		if m.KnownRobZhuang {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.TotalNumberOfGame != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.TotalNumberOfGame))
		i--
		dAtA[i] = 0x48
	}
	if m.KnownCard {
		i--
		if m.KnownCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.MapWaitTime) > 0 {
		for k := range m.MapWaitTime {
			v := m.MapWaitTime[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CardTypeHasKind {
		i--
		if m.CardTypeHasKind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MapCardTypeRate) > 0 {
		for k := range m.MapCardTypeRate {
			v := m.MapCardTypeRate[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MapBetRate) > 0 {
		for k := range m.MapBetRate {
			v := m.MapBetRate[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MapRobZhuangRate) > 0 {
		for k := range m.MapRobZhuangRate {
			v := m.MapRobZhuangRate[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BaseScore != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BaseScore))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoomInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoomInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoomType != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomType))
		i--
		dAtA[i] = 0x18
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayerNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.PlayerNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuNiuGetAllRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuNiuGetAllRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuNiuGetAllRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomInfos) > 0 {
		for iNdEx := len(m.RoomInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoomInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2SCreateNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SCreateNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SCreateNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PlayerNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.PlayerNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CCreateNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CCreateNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CCreateNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *C2SNiuniuRoomConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SNiuniuRoomConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SNiuniuRoomConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomIds) > 0 {
		dAtA2 := make([]byte, len(m.RoomIds)*10)
		var j1 int
		for _, num := range m.RoomIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuRoomConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuRoomConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuRoomConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cfgs) > 0 {
		for iNdEx := len(m.Cfgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cfgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReconnectSnap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReconnectSnap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReconnectSnap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapPlayerGold) > 0 {
		for k := range m.MapPlayerGold {
			v := m.MapPlayerGold[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.UnknownCard != nil {
		{
			size, err := m.UnknownCard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MapWinOrLose) > 0 {
		for k := range m.MapWinOrLose {
			v := m.MapWinOrLose[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.MapShowCard) > 0 {
		for k := range m.MapShowCard {
			v := m.MapShowCard[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.BankerId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BankerId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MapBet) > 0 {
		for k := range m.MapBet {
			v := m.MapBet[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PlayerUids) > 0 {
		dAtA6 := make([]byte, len(m.PlayerUids)*10)
		var j5 int
		for _, num := range m.PlayerUids {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KnownCards) > 0 {
		for iNdEx := len(m.KnownCards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KnownCards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MapRobZhuang) > 0 {
		for k := range m.MapRobZhuang {
			v := m.MapRobZhuang[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Prepper) > 0 {
		dAtA8 := make([]byte, len(m.Prepper)*10)
		var j7 int
		for _, num := range m.Prepper {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2SEnterNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SEnterNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SEnterNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Wxid) > 0 {
		i -= len(m.Wxid)
		copy(dAtA[i:], m.Wxid)
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(len(m.Wxid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Lobby2GateEnterNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lobby2GateEnterNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lobby2GateEnterNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NiuniuServerId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.NiuniuServerId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.C2SEnterNiuniuRoom) > 0 {
		i -= len(m.C2SEnterNiuniuRoom)
		copy(dAtA[i:], m.C2SEnterNiuniuRoom)
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(len(m.C2SEnterNiuniuRoom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CEnterNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CEnterNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CEnterNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Owner != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Owner))
		i--
		dAtA[i] = 0x50
	}
	if m.NumberOfGame != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.NumberOfGame))
		i--
		dAtA[i] = 0x48
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RcSnap != nil {
		{
			size, err := m.RcSnap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.CountDown != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.CountDown))
		i--
		dAtA[i] = 0x30
	}
	if m.BystanderNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BystanderNum))
		i--
		dAtA[i] = 0x28
	}
	if m.RoomStatus != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomStatus))
		i--
		dAtA[i] = 0x20
	}
	if m.PlayerBaseInfo != nil {
		{
			size, err := m.PlayerBaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MapPlayerBaseInfo) > 0 {
		for k := range m.MapPlayerBaseInfo {
			v := m.MapPlayerBaseInfo[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2COtherPlayerEnterNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2COtherPlayerEnterNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2COtherPlayerEnterNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BystanderNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BystanderNum))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SLeaveNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SLeaveNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SLeaveNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *S2CLeaveNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CLeaveNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CLeaveNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CBroadcastLeaveNiuniuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CBroadcastLeaveNiuniuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CBroadcastLeaveNiuniuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatIndex != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.BystanderNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BystanderNum))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuClientDisconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuClientDisconnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuClientDisconnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SeatIndex != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.SeatIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuBroadcastRoomStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuBroadcastRoomStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuBroadcastRoomStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CountDown != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.CountDown))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomStatus != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomStatus))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SNiuniuReady) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SNiuniuReady) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SNiuniuReady) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuReady) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuReady) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuReady) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BystanderNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BystanderNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuSendKnownCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuSendKnownCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuSendKnownCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2SNiuniuRobZhuang) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SNiuniuRobZhuang) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SNiuniuRobZhuang) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rate != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuRobZhuang) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuRobZhuang) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuRobZhuang) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.Rate != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CConfirmBanker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CConfirmBanker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CConfirmBanker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uids) > 0 {
		dAtA14 := make([]byte, len(m.Uids)*10)
		var j13 int
		for _, num := range m.Uids {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x1a
	}
	if m.Rate != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Rate))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SNiuniuBet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SNiuniuBet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SNiuniuBet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Bet != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuBet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuBet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuBet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.Bet != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuSendOneUnknownCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuSendOneUnknownCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuSendOneUnknownCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Card != nil {
		{
			size, err := m.Card.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *C2SNiuniuShowCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SNiuniuShowCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SNiuniuShowCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuShowCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuShowCard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuShowCard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CardComb) > 0 {
		for iNdEx := len(m.CardComb) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CardComb[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CardType != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.CardType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cards) > 0 {
		for iNdEx := len(m.Cards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuSettle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuSettle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuSettle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapWinOrLoseFinal) > 0 {
		for k := range m.MapWinOrLoseFinal {
			v := m.MapWinOrLoseFinal[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MapPlayerGold) > 0 {
		for k := range m.MapPlayerGold {
			v := m.MapPlayerGold[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MapWinOrLose) > 0 {
		for k := range m.MapWinOrLose {
			v := m.MapWinOrLose[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuHaveASeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuHaveASeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuHaveASeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Player != nil {
		{
			size, err := m.Player.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BystanderNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BystanderNum))
		i--
		dAtA[i] = 0x18
	}
	if m.IsSitDown {
		i--
		if m.IsSitDown {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SeatIdx != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.SeatIdx))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuLeaveTheSeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuLeaveTheSeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuLeaveTheSeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BystanderNum != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BystanderNum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MapUidSeat) > 0 {
		for k := range m.MapUidSeat {
			v := m.MapUidSeat[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *C2SNiuniuPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SNiuniuPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SNiuniuPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Timestamp != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *C2SSelfBuildNiuNiuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SSelfBuildNiuNiuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *C2SSelfBuildNiuNiuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Wxid) > 0 {
		i -= len(m.Wxid)
		copy(dAtA[i:], m.Wxid)
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(len(m.Wxid)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Uid != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RoomRate != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomRate))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RoomPublic != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomPublic))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AlongTheBucket != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.AlongTheBucket))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.HeFights != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.HeFights))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.KingLaiKingOf != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.KingLaiKingOf))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.FaceCards != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.FaceCards))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.DarkGrabBanker != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.DarkGrabBanker))
		i--
		dAtA[i] = 0x78
	}
	if m.BetLimit != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BetLimit))
		i--
		dAtA[i] = 0x70
	}
	if m.BuyHorse != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BuyHorse))
		i--
		dAtA[i] = 0x68
	}
	if m.DoubleBottomPour != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.DoubleBottomPour))
		i--
		dAtA[i] = 0x60
	}
	if m.TheShoot != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.TheShoot))
		i--
		dAtA[i] = 0x58
	}
	if m.Add != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.Add))
		i--
		dAtA[i] = 0x50
	}
	if m.PlayerNumber != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.PlayerNumber))
		i--
		dAtA[i] = 0x48
	}
	if m.PlayerPushNumber != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.PlayerPushNumber))
		i--
		dAtA[i] = 0x40
	}
	if m.TheBiggestRobZhuang != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.TheBiggestRobZhuang))
		i--
		dAtA[i] = 0x38
	}
	if m.SpecialDoubleRules != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.SpecialDoubleRules))
		i--
		dAtA[i] = 0x30
	}
	if m.DoubleRules != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.DoubleRules))
		i--
		dAtA[i] = 0x28
	}
	if m.NumberOfGame != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.NumberOfGame))
		i--
		dAtA[i] = 0x20
	}
	if m.LowGrade != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.LowGrade))
		i--
		dAtA[i] = 0x18
	}
	if m.LowGradeType != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.LowGradeType))
		i--
		dAtA[i] = 0x10
	}
	if m.PlayingMethod != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.PlayingMethod))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CSelfBuildNiuNiuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CSelfBuildNiuNiuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CSelfBuildNiuNiuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumberOfGames != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.NumberOfGames))
		i--
		dAtA[i] = 0x58
	}
	if m.PlayerBaseInfo != nil {
		{
			size, err := m.PlayerBaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.MapPlayerBaseInfo) > 0 {
		for k := range m.MapPlayerBaseInfo {
			v := m.MapPlayerBaseInfo[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.KnownCard {
		i--
		if m.KnownCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.MapWaitTime) > 0 {
		for k := range m.MapWaitTime {
			v := m.MapWaitTime[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.CardTypeHasKind {
		i--
		if m.CardTypeHasKind {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MapCardTypeRate) > 0 {
		for k := range m.MapCardTypeRate {
			v := m.MapCardTypeRate[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MapBetRate) > 0 {
		for k := range m.MapBetRate {
			v := m.MapBetRate[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MapRobZhuangRate) > 0 {
		for k := range m.MapRobZhuangRate {
			v := m.MapRobZhuangRate[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BaseScore != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.BaseScore))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Lobby2GateSelfBuildNiuNiuRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Lobby2GateSelfBuildNiuNiuRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Lobby2GateSelfBuildNiuNiuRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NiuniuServerId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.NiuniuServerId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.C2SSelfBuildNiuNiuRoom) > 0 {
		i -= len(m.C2SSelfBuildNiuNiuRoom)
		copy(dAtA[i:], m.C2SSelfBuildNiuNiuRoom)
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(len(m.C2SSelfBuildNiuNiuRoom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuNiuGetAllSelfBuildRoom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuNiuGetAllSelfBuildRoom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuNiuGetAllSelfBuildRoom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RoomInfos) > 0 {
		for iNdEx := len(m.RoomInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RoomInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNiuniuStruct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuNiuGameNumber) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuNiuGameNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuNiuGameNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumberOfGame != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.NumberOfGame))
		i--
		dAtA[i] = 0x10
	}
	if m.RoomId != 0 {
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(m.RoomId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuNiuRoomWinLose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuNiuRoomWinLose) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuNiuRoomWinLose) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.MapWinLose) > 0 {
		for k := range m.MapWinLose {
			v := m.MapWinLose[k]
			baseI := i
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNiuniuStruct(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *S2CNiuniuGameStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *S2CNiuniuGameStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *S2CNiuniuGameStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Uids) > 0 {
		dAtA20 := make([]byte, len(m.Uids)*10)
		var j19 int
		for _, num := range m.Uids {
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintNiuniuStruct(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNiuniuStruct(dAtA []byte, offset int, v uint64) int {
	offset -= sovNiuniuStruct(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RoomConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.BaseScore != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BaseScore))
	}
	if len(m.MapRobZhuangRate) > 0 {
		for k, v := range m.MapRobZhuangRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapBetRate) > 0 {
		for k, v := range m.MapBetRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapCardTypeRate) > 0 {
		for k, v := range m.MapCardTypeRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.CardTypeHasKind {
		n += 2
	}
	if len(m.MapWaitTime) > 0 {
		for k, v := range m.MapWaitTime {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.KnownCard {
		n += 2
	}
	if m.TotalNumberOfGame != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.TotalNumberOfGame))
	}
	if m.KnownRobZhuang {
		n += 2
	}
	if m.Kan {
		n += 2
	}
	if m.Shun {
		n += 2
	}
	if m.Faster {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RoomInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.PlayerNum))
	}
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.RoomType != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuNiuGetAllRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomInfos) > 0 {
		for _, e := range m.RoomInfos {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SCreateNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayerNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.PlayerNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CCreateNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SNiuniuRoomConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomIds) > 0 {
		l = 0
		for _, e := range m.RoomIds {
			l += sovNiuniuStruct(uint64(e))
		}
		n += 1 + sovNiuniuStruct(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuRoomConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cfgs) > 0 {
		for _, e := range m.Cfgs {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReconnectSnap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Prepper) > 0 {
		l = 0
		for _, e := range m.Prepper {
			l += sovNiuniuStruct(uint64(e))
		}
		n += 1 + sovNiuniuStruct(uint64(l)) + l
	}
	if len(m.MapRobZhuang) > 0 {
		for k, v := range m.MapRobZhuang {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.KnownCards) > 0 {
		for _, e := range m.KnownCards {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if len(m.PlayerUids) > 0 {
		l = 0
		for _, e := range m.PlayerUids {
			l += sovNiuniuStruct(uint64(e))
		}
		n += 1 + sovNiuniuStruct(uint64(l)) + l
	}
	if len(m.MapBet) > 0 {
		for k, v := range m.MapBet {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.BankerId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BankerId))
	}
	if len(m.MapShowCard) > 0 {
		for k, v := range m.MapShowCard {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNiuniuStruct(uint64(l))
			}
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + l
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapWinOrLose) > 0 {
		for k, v := range m.MapWinOrLose {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.UnknownCard != nil {
		l = m.UnknownCard.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if len(m.MapPlayerGold) > 0 {
		for k, v := range m.MapPlayerGold {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SEnterNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.Uid != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Uid))
	}
	l = len(m.Wxid)
	if l > 0 {
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Lobby2GateEnterNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.C2SEnterNiuniuRoom)
	if l > 0 {
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.NiuniuServerId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.NiuniuServerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CEnterNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if len(m.MapPlayerBaseInfo) > 0 {
		for k, v := range m.MapPlayerBaseInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNiuniuStruct(uint64(l))
			}
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + l
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.PlayerBaseInfo != nil {
		l = m.PlayerBaseInfo.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.RoomStatus != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomStatus))
	}
	if m.BystanderNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BystanderNum))
	}
	if m.CountDown != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.CountDown))
	}
	if m.RcSnap != nil {
		l = m.RcSnap.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.NumberOfGame != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.NumberOfGame))
	}
	if m.Owner != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Owner))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2COtherPlayerEnterNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.BystanderNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BystanderNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SLeaveNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CLeaveNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CBroadcastLeaveNiuniuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.BystanderNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BystanderNum))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.SeatIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuClientDisconnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.SeatIndex != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.SeatIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuBroadcastRoomStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomStatus != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomStatus))
	}
	if m.CountDown != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.CountDown))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SNiuniuReady) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuReady) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Uid))
	}
	if m.BystanderNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BystanderNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuSendKnownCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SNiuniuRobZhuang) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Rate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuRobZhuang) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rate != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Rate))
	}
	if m.Uid != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CConfirmBanker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Uid))
	}
	if m.Rate != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Rate))
	}
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovNiuniuStruct(uint64(e))
		}
		n += 1 + sovNiuniuStruct(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SNiuniuBet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bet != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Bet))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuBet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bet != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Bet))
	}
	if m.Uid != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuSendOneUnknownCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SNiuniuShowCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuShowCard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Uid))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if m.CardType != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.CardType))
	}
	if len(m.CardComb) > 0 {
		for _, e := range m.CardComb {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuSettle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MapWinOrLose) > 0 {
		for k, v := range m.MapWinOrLose {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapPlayerGold) > 0 {
		for k, v := range m.MapPlayerGold {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapWinOrLoseFinal) > 0 {
		for k, v := range m.MapWinOrLoseFinal {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuHaveASeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeatIdx != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.SeatIdx))
	}
	if m.IsSitDown {
		n += 2
	}
	if m.BystanderNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BystanderNum))
	}
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuLeaveTheSeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MapUidSeat) > 0 {
		for k, v := range m.MapUidSeat {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.BystanderNum != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BystanderNum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SNiuniuPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *C2SSelfBuildNiuNiuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlayingMethod != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.PlayingMethod))
	}
	if m.LowGradeType != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.LowGradeType))
	}
	if m.LowGrade != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.LowGrade))
	}
	if m.NumberOfGame != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.NumberOfGame))
	}
	if m.DoubleRules != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.DoubleRules))
	}
	if m.SpecialDoubleRules != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.SpecialDoubleRules))
	}
	if m.TheBiggestRobZhuang != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.TheBiggestRobZhuang))
	}
	if m.PlayerPushNumber != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.PlayerPushNumber))
	}
	if m.PlayerNumber != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.PlayerNumber))
	}
	if m.Add != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.Add))
	}
	if m.TheShoot != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.TheShoot))
	}
	if m.DoubleBottomPour != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.DoubleBottomPour))
	}
	if m.BuyHorse != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BuyHorse))
	}
	if m.BetLimit != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BetLimit))
	}
	if m.DarkGrabBanker != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.DarkGrabBanker))
	}
	if m.FaceCards != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.FaceCards))
	}
	if m.KingLaiKingOf != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.KingLaiKingOf))
	}
	if m.HeFights != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.HeFights))
	}
	if m.AlongTheBucket != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.AlongTheBucket))
	}
	if m.RoomPublic != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.RoomPublic))
	}
	if m.RoomRate != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.RoomRate))
	}
	if m.Uid != 0 {
		n += 2 + sovNiuniuStruct(uint64(m.Uid))
	}
	l = len(m.Wxid)
	if l > 0 {
		n += 2 + l + sovNiuniuStruct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CSelfBuildNiuNiuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.BaseScore != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.BaseScore))
	}
	if len(m.MapRobZhuangRate) > 0 {
		for k, v := range m.MapRobZhuangRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapBetRate) > 0 {
		for k, v := range m.MapBetRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if len(m.MapCardTypeRate) > 0 {
		for k, v := range m.MapCardTypeRate {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.CardTypeHasKind {
		n += 2
	}
	if len(m.MapWaitTime) > 0 {
		for k, v := range m.MapWaitTime {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.KnownCard {
		n += 2
	}
	if len(m.MapPlayerBaseInfo) > 0 {
		for k, v := range m.MapPlayerBaseInfo {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovNiuniuStruct(uint64(l))
			}
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + l
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.PlayerBaseInfo != nil {
		l = m.PlayerBaseInfo.Size()
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.NumberOfGames != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.NumberOfGames))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Lobby2GateSelfBuildNiuNiuRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.C2SSelfBuildNiuNiuRoom)
	if l > 0 {
		n += 1 + l + sovNiuniuStruct(uint64(l))
	}
	if m.NiuniuServerId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.NiuniuServerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuNiuGetAllSelfBuildRoom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RoomInfos) > 0 {
		for _, e := range m.RoomInfos {
			l = e.Size()
			n += 1 + l + sovNiuniuStruct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuNiuGameNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.RoomId))
	}
	if m.NumberOfGame != 0 {
		n += 1 + sovNiuniuStruct(uint64(m.NumberOfGame))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuNiuRoomWinLose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MapWinLose) > 0 {
		for k, v := range m.MapWinLose {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNiuniuStruct(uint64(k)) + 1 + sovNiuniuStruct(uint64(v))
			n += mapEntrySize + 1 + sovNiuniuStruct(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *S2CNiuniuGameStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovNiuniuStruct(uint64(e))
		}
		n += 1 + sovNiuniuStruct(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNiuniuStruct(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNiuniuStruct(x uint64) (n int) {
	return sovNiuniuStruct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RoomConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: roomConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: roomConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseScore", wireType)
			}
			m.BaseScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRobZhuangRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapRobZhuangRate == nil {
				m.MapRobZhuangRate = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapRobZhuangRate[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBetRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBetRate == nil {
				m.MapBetRate = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBetRate[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapCardTypeRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapCardTypeRate == nil {
				m.MapCardTypeRate = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapCardTypeRate[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardTypeHasKind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CardTypeHasKind = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapWaitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapWaitTime == nil {
				m.MapWaitTime = make(map[uint32]int64)
			}
			var mapkey uint32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapWaitTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KnownCard = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNumberOfGame", wireType)
			}
			m.TotalNumberOfGame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNumberOfGame |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownRobZhuang", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KnownRobZhuang = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kan = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shun = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Faster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Faster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: roomInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: roomInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerNum", wireType)
			}
			m.PlayerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomType", wireType)
			}
			m.RoomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomType |= commonProto.RoomType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuNiuGetAllRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuNiuGetAllRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuNiuGetAllRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomInfos = append(m.RoomInfos, &RoomInfo{})
			if err := m.RoomInfos[len(m.RoomInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SCreateNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sCreateNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sCreateNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerNum", wireType)
			}
			m.PlayerNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CCreateNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cCreateNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cCreateNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SNiuniuRoomConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sNiuniuRoomConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sNiuniuRoomConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RoomIds = append(m.RoomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RoomIds) == 0 {
					m.RoomIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RoomIds = append(m.RoomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuRoomConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuRoomConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuRoomConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cfgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cfgs = append(m.Cfgs, &RoomConfig{})
			if err := m.Cfgs[len(m.Cfgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReconnectSnap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: reconnectSnap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: reconnectSnap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Prepper = append(m.Prepper, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Prepper) == 0 {
					m.Prepper = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Prepper = append(m.Prepper, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Prepper", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRobZhuang", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapRobZhuang == nil {
				m.MapRobZhuang = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapRobZhuang[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KnownCards = append(m.KnownCards, &commonProto.PokerCard{})
			if err := m.KnownCards[len(m.KnownCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PlayerUids = append(m.PlayerUids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PlayerUids) == 0 {
					m.PlayerUids = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PlayerUids = append(m.PlayerUids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerUids", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBet == nil {
				m.MapBet = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBet[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BankerId", wireType)
			}
			m.BankerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BankerId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapShowCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapShowCard == nil {
				m.MapShowCard = make(map[uint32]*S2CNiuniuShowCard)
			}
			var mapkey uint32
			var mapvalue *S2CNiuniuShowCard
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &S2CNiuniuShowCard{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapShowCard[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapWinOrLose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapWinOrLose == nil {
				m.MapWinOrLose = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapWinOrLose[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnknownCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnknownCard == nil {
				m.UnknownCard = &commonProto.PokerCard{}
			}
			if err := m.UnknownCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPlayerGold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapPlayerGold == nil {
				m.MapPlayerGold = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapPlayerGold[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SEnterNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sEnterNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sEnterNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lobby2GateEnterNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lobby2GateEnterNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lobby2GateEnterNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2SEnterNiuniuRoom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C2SEnterNiuniuRoom = append(m.C2SEnterNiuniuRoom[:0], dAtA[iNdEx:postIndex]...)
			if m.C2SEnterNiuniuRoom == nil {
				m.C2SEnterNiuniuRoom = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NiuniuServerId", wireType)
			}
			m.NiuniuServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NiuniuServerId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CEnterNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cEnterNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cEnterNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapPlayerBaseInfo == nil {
				m.MapPlayerBaseInfo = make(map[uint32]*commonProto.PlayerBaseInfo)
			}
			var mapkey uint32
			var mapvalue *commonProto.PlayerBaseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &commonProto.PlayerBaseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapPlayerBaseInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerBaseInfo == nil {
				m.PlayerBaseInfo = &commonProto.PlayerBaseInfo{}
			}
			if err := m.PlayerBaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomStatus", wireType)
			}
			m.RoomStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomStatus |= NiuniuRoomStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BystanderNum", wireType)
			}
			m.BystanderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BystanderNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDown", wireType)
			}
			m.CountDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDown |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RcSnap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RcSnap == nil {
				m.RcSnap = &ReconnectSnap{}
			}
			if err := m.RcSnap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &RoomConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfGame", wireType)
			}
			m.NumberOfGame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfGame |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2COtherPlayerEnterNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cOtherPlayerEnterNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cOtherPlayerEnterNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BystanderNum", wireType)
			}
			m.BystanderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BystanderNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SLeaveNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sLeaveNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sLeaveNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CLeaveNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cLeaveNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cLeaveNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CBroadcastLeaveNiuniuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cBroadcastLeaveNiuniuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cBroadcastLeaveNiuniuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BystanderNum", wireType)
			}
			m.BystanderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BystanderNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuClientDisconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuClientDisconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuClientDisconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIndex", wireType)
			}
			m.SeatIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuBroadcastRoomStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuBroadcastRoomStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuBroadcastRoomStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomStatus", wireType)
			}
			m.RoomStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomStatus |= NiuniuRoomStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountDown", wireType)
			}
			m.CountDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CountDown |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SNiuniuReady) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sNiuniuReady: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sNiuniuReady: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuReady) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuReady: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuReady: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BystanderNum", wireType)
			}
			m.BystanderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BystanderNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuSendKnownCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuSendKnownCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuSendKnownCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &commonProto.PokerCard{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SNiuniuRobZhuang) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sNiuniuRobZhuang: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sNiuniuRobZhuang: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuRobZhuang) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuRobZhuang: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuRobZhuang: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CConfirmBanker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cConfirmBanker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cConfirmBanker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			m.Rate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SNiuniuBet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sNiuniuBet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sNiuniuBet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuBet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuBet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuBet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuSendOneUnknownCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuSendOneUnknownCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuSendOneUnknownCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &commonProto.PokerCard{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SNiuniuShowCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sNiuniuShowCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sNiuniuShowCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuShowCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuShowCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuShowCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &commonProto.PokerCard{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardType", wireType)
			}
			m.CardType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardComb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardComb = append(m.CardComb, &commonProto.PokerCard{})
			if err := m.CardComb[len(m.CardComb)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuSettle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuSettle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuSettle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapWinOrLose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapWinOrLose == nil {
				m.MapWinOrLose = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapWinOrLose[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPlayerGold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapPlayerGold == nil {
				m.MapPlayerGold = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapPlayerGold[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapWinOrLoseFinal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapWinOrLoseFinal == nil {
				m.MapWinOrLoseFinal = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapWinOrLoseFinal[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuHaveASeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuHaveASeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuHaveASeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeatIdx", wireType)
			}
			m.SeatIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeatIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSitDown", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSitDown = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BystanderNum", wireType)
			}
			m.BystanderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BystanderNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &commonProto.PlayerBaseInfo{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuLeaveTheSeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuLeaveTheSeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuLeaveTheSeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapUidSeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapUidSeat == nil {
				m.MapUidSeat = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapUidSeat[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BystanderNum", wireType)
			}
			m.BystanderNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BystanderNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SNiuniuPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sNiuniuPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sNiuniuPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuPong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuPong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SSelfBuildNiuNiuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: c2sSelfBuildNiuNiuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: c2sSelfBuildNiuNiuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayingMethod", wireType)
			}
			m.PlayingMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayingMethod |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowGradeType", wireType)
			}
			m.LowGradeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowGradeType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowGrade", wireType)
			}
			m.LowGrade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowGrade |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfGame", wireType)
			}
			m.NumberOfGame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfGame |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleRules", wireType)
			}
			m.DoubleRules = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoubleRules |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialDoubleRules", wireType)
			}
			m.SpecialDoubleRules = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialDoubleRules |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheBiggestRobZhuang", wireType)
			}
			m.TheBiggestRobZhuang = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheBiggestRobZhuang |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerPushNumber", wireType)
			}
			m.PlayerPushNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerPushNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerNumber", wireType)
			}
			m.PlayerNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			m.Add = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Add |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheShoot", wireType)
			}
			m.TheShoot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheShoot |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleBottomPour", wireType)
			}
			m.DoubleBottomPour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DoubleBottomPour |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyHorse", wireType)
			}
			m.BuyHorse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyHorse |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetLimit", wireType)
			}
			m.BetLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BetLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DarkGrabBanker", wireType)
			}
			m.DarkGrabBanker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DarkGrabBanker |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceCards", wireType)
			}
			m.FaceCards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FaceCards |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KingLaiKingOf", wireType)
			}
			m.KingLaiKingOf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KingLaiKingOf |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeFights", wireType)
			}
			m.HeFights = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeFights |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlongTheBucket", wireType)
			}
			m.AlongTheBucket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlongTheBucket |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomPublic", wireType)
			}
			m.RoomPublic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomPublic |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomRate", wireType)
			}
			m.RoomRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomRate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CSelfBuildNiuNiuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cSelfBuildNiuNiuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cSelfBuildNiuNiuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseScore", wireType)
			}
			m.BaseScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapRobZhuangRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapRobZhuangRate == nil {
				m.MapRobZhuangRate = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapRobZhuangRate[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapBetRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapBetRate == nil {
				m.MapBetRate = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapBetRate[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapCardTypeRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapCardTypeRate == nil {
				m.MapCardTypeRate = make(map[uint32]uint32)
			}
			var mapkey uint32
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapCardTypeRate[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardTypeHasKind", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CardTypeHasKind = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapWaitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapWaitTime == nil {
				m.MapWaitTime = make(map[uint32]int64)
			}
			var mapkey uint32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapWaitTime[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KnownCard = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapPlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapPlayerBaseInfo == nil {
				m.MapPlayerBaseInfo = make(map[uint32]*commonProto.PlayerBaseInfo)
			}
			var mapkey uint32
			var mapvalue *commonProto.PlayerBaseInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &commonProto.PlayerBaseInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapPlayerBaseInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlayerBaseInfo == nil {
				m.PlayerBaseInfo = &commonProto.PlayerBaseInfo{}
			}
			if err := m.PlayerBaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfGames", wireType)
			}
			m.NumberOfGames = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfGames |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Lobby2GateSelfBuildNiuNiuRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: lobby2GateSelfBuildNiuNiuRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: lobby2GateSelfBuildNiuNiuRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field C2SSelfBuildNiuNiuRoom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.C2SSelfBuildNiuNiuRoom = append(m.C2SSelfBuildNiuNiuRoom[:0], dAtA[iNdEx:postIndex]...)
			if m.C2SSelfBuildNiuNiuRoom == nil {
				m.C2SSelfBuildNiuNiuRoom = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NiuniuServerId", wireType)
			}
			m.NiuniuServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NiuniuServerId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuNiuGetAllSelfBuildRoom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuNiuGetAllSelfBuildRoom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuNiuGetAllSelfBuildRoom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomInfos = append(m.RoomInfos, &RoomInfo{})
			if err := m.RoomInfos[len(m.RoomInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuNiuGameNumber) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuNiuGameNumber: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuNiuGameNumber: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfGame", wireType)
			}
			m.NumberOfGame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfGame |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuNiuRoomWinLose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuNiuRoomWinLose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuNiuRoomWinLose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapWinLose", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapWinLose == nil {
				m.MapWinLose = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNiuniuStruct
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MapWinLose[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *S2CNiuniuGameStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: s2cNiuniuGameStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: s2cNiuniuGameStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNiuniuStruct
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNiuniuStruct
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uids) == 0 {
					m.Uids = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNiuniuStruct
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNiuniuStruct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNiuniuStruct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNiuniuStruct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNiuniuStruct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNiuniuStruct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNiuniuStruct
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNiuniuStruct
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNiuniuStruct
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNiuniuStruct        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNiuniuStruct          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNiuniuStruct = fmt.Errorf("proto: unexpected end of group")
)
